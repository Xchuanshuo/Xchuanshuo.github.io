<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>实现一个FC模拟器 | legend＇s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言前段时间无意中浏览到了描述FC(Family Computer)游戏的一些工作原理的博客，瞬间勾起了儿时对小霸王游戏机如痴如醉的过往，看到网上从以前游戏卡带中导出来的游戏：超级玛丽、魂斗罗等才几十k">
<meta property="og:type" content="article">
<meta property="og:title" content="实现一个FC模拟器">
<meta property="og:url" content="http://blog.cspojie.cn/2020/06/02/实现一个FC模拟器/index.html">
<meta property="og:site_name" content="legend＇s blog">
<meta property="og:description" content="前言前段时间无意中浏览到了描述FC(Family Computer)游戏的一些工作原理的博客，瞬间勾起了儿时对小霸王游戏机如痴如醉的过往，看到网上从以前游戏卡带中导出来的游戏：超级玛丽、魂斗罗等才几十k">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/29/tmrMr9.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/29/tmrWrj.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/29/tmsUYV.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/29/tmspi6.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/29/tmsFQe.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/29/tmsZdI.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/29/tub1ot.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/29/tKYErt.png">
<meta property="og:image" content="https://pic4.zhimg.com/v2-12b0d40ad74d27ce6d8ff2499c6df163_b.webp">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/30/tMgQ3R.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/30/tMjIQP.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/30/tQSrfH.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/30/tQplut.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/30/tQAMi6.png">
<meta property="og:image" content="http://wiki.nesdev.com/w/images/b/bf/NTS_scrolling_seam.gif">
<meta property="og:image" content="https://s1.ax1x.com/2020/06/02/tYpCTA.png">
<meta property="og:updated_time" content="2020-06-12T15:30:37.228Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现一个FC模拟器">
<meta name="twitter:description" content="前言前段时间无意中浏览到了描述FC(Family Computer)游戏的一些工作原理的博客，瞬间勾起了儿时对小霸王游戏机如痴如醉的过往，看到网上从以前游戏卡带中导出来的游戏：超级玛丽、魂斗罗等才几十k">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/05/29/tmrMr9.png">
  
    <link rel="alternative" href="/atom.xml" title="legend＇s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Legend</a></h1>
        </hgroup>

        
        <p class="header-subtitle">最大的幸运是年轻时有着对梦想执着的激情</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/about">留言打卡</a></li>
                        
                            <li><a href="/FrontEndGuide">后端导航</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="/2414605975@gmail.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/Xchuanshuo" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                            
                                <a class="fl google" target="_blank" href="/aixs241460@gmail.com" title="google">google</a>
                            
                                <a class="fl linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Android/" style="font-size: 18.33px;">Android</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Java/" style="font-size: 11.67px;">Java</a> <a href="/tags/Linux/" style="font-size: 16.67px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Python/" style="font-size: 18.33px;">Python</a> <a href="/tags/Tomcat/" style="font-size: 11.67px;">Tomcat</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/图/" style="font-size: 11.67px;">图</a> <a href="/tags/字符串匹配/" style="font-size: 10px;">字符串匹配</a> <a href="/tags/常用命令/" style="font-size: 10px;">常用命令</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/架构/" style="font-size: 10px;">架构</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/源码分析/" style="font-size: 11.67px;">源码分析</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/算法与数据结构/" style="font-size: 20px;">算法与数据结构</a> <a href="/tags/编程思想/" style="font-size: 10px;">编程思想</a> <a href="/tags/设计模式/" style="font-size: 11.67px;">设计模式</a> <a href="/tags/随笔/" style="font-size: 13.33px;">随笔</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jikedaohang.com/">极客导航</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.ofmonkey.com/">在线工具</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">虽生有涯而知无涯，但进一寸有一寸的欢喜！</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Legend</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Legend</a></h1>
            </hgroup>
            
            <p class="header-subtitle">最大的幸运是年轻时有着对梦想执着的激情</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/about">留言打卡</a></li>
                
                    <li><a href="/FrontEndGuide">后端导航</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="/2414605975@gmail.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/Xchuanshuo" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                    
                        <a class="google" target="_blank" href="/aixs241460@gmail.com" title="google">google</a>
                    
                        <a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-实现一个FC模拟器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/02/实现一个FC模拟器/" class="article-date">
      <time datetime="2020-06-02T03:42:39.000Z" itemprop="datePublished">2020-06-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      实现一个FC模拟器
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a><a class="article-category-link" href="/categories/Java/模拟器/">模拟器</a><a class="article-category-link" href="/categories/Java/模拟器/体系结构/">体系结构</a>
    </div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间无意中浏览到了描述FC(Family Computer)游戏的一些工作原理的博客，瞬间勾起了儿时对小霸王游戏机如痴如醉的过往，看到网上从以前游戏卡带中导出来的游戏：超级玛丽、魂斗罗等才几十k<a id="more"></a>大小，大的也不过几百k，极少数超过1M的，而这点空间现在的一张普通质量的图片可能都存不下。所以想到了不如自己实现一个FC模拟器，一探它背后神秘的魔法。即是重新追忆一下那些逝去的时光，又是对计算基础知识很好的一个实践。然现实很骨感，网上能找得到的相关硬件资料太少，资料比较全面的就是NesDev，但是全英文，而且很多东西过于详细，花了很长时间读可能还找不到重点在哪里，除非做过类似的东西否则很难就此上手。所以写篇博客记录一下整个实现的流程。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://s1.ax1x.com/2020/05/29/tmrMr9.png" alt=""></td>
<td><img src="https://s1.ax1x.com/2020/05/29/tmrWrj.png" alt=""></td>
<td><img src="https://s1.ax1x.com/2020/05/29/tmsUYV.png" alt=""></td>
</tr>
<tr>
<td><img src="https://s1.ax1x.com/2020/05/29/tmspi6.png" alt=""></td>
<td><img src="https://s1.ax1x.com/2020/05/29/tmsFQe.png" alt=""></td>
<td><img src="https://s1.ax1x.com/2020/05/29/tmsZdI.png" alt=""> </td>
</tr>
</tbody>
</table>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>所谓模拟器，实际就是我们在软件层面来模拟硬件的工作，也就是说实现一个FC程序的执行环境。要实现这么一个模拟器，首先就是要清楚FC主要由哪些硬件构成以及各个硬件是如何协作的，反正现代的计算机基本都是基于冯洛伊曼体系啦。与我们一般的电脑一样，主要就是CPU、内存、显卡、输入设备、输出设备几部分。具体到FC，以前游戏机都是插卡的，所以卡带也要算一部分。接下来描述一下大致的过程，主机通电后</p>
<ul>
<li>1.卡带的加载<br>游戏的数据主要包括图像和程序，所以第一步首先就是根据固定的头部解析nes文件(卡带硬件导出的)，拿到相关的数据后，就可以开始将程序和图像分别装载到主内存和显存，而CPU主要就是和主内存打交道，包括其它的硬件也都是通过CPU内部的IO寄存器映射到主内存，IO寄存器可以当作是CPU与外部设备通过总线连接的端点。当然具体实现时，直接通过操作具体的某个内存地址来实现与其它硬件的通信就可以了。</li>
<li>2.CPU运行程序代码<br>CPU(Center Processing Unit)对计算机而言，始终是最核心的硬件，其它组件的运行都是通过它来带动的。对于FC，通电重置后会触发一个RESET中断，也就是会将CPU的指令指针寄存器PC(Program Counter)跳转到RESET中断存储的地址，因为PC总是存储的程序下一条要执行指令的内存地址嘛，所以程序也就从这里开始执行了。执行的过程也就是[取指令]-&gt;[指令译码]-&gt;[取操作数]-&gt;[计算]。</li>
<li>3.PPU开始读取图像数据并进渲染<br>图像处理单元PPU(Picture Processing Unit)也就是我们常说的显卡，主要就是用来处理图形的渲染、窗口的显示，一般显卡会有自己单独的一块内存，主要用来存储图像以及相关的信息。对于FC，PPU会定期从显存中抓取游戏背景、精灵的数据，并渲染到窗口上。这里说的定期，实际上就是需要与CPU的时钟周期进行同步啦，这样才能保证获取到的数据是正确的。一般来说，PPU需要有比CPU更快的执行速度，CPU除了执行指令，还有对各个硬件进行协调的功能，对于PPU而言，也是通过几个IO寄存器来进行的，一般CPU执行一次，屏幕至少要抓取几个像素点。</li>
<li>4.输入与输出<br>输入设备主要包括手柄、光枪之类的，和现在的计算机不太一样，我们用键盘输入时一般都是通过中断来通知CPU，键盘的中断处理程序接着再根据输入的扫描码翻译成键盘上对应按键值。对于FC而言，是程序通过代码定期(一般是在一帧绘制完成后)按手柄按键顺序从内存映射的IO寄存器中读取输入的值。输出主要就是包括屏幕的像素点以及声音。<br><img src="https://s1.ax1x.com/2020/05/29/tub1ot.png" alt=""><br>各个组件的协作见上图，接下来就依次介绍一下各个部以及一些额外的扩展。</li>
</ul>
<h2 id="游戏卡带"><a href="#游戏卡带" class="headerlink" title="游戏卡带"></a>游戏卡带</h2><p>这部分需要读取nes文件并按部就班的解析和存储相关的信息，nes文件实际就是FC平台的可执行文件，与Windows上的PE(常见的.exe)、Linux上面的ELF可执行文件一样，都不是纯二进制程序，额外包含了一些固定的头部信息。这是平台所规定的，需要从中解析出实际的程序才能放到CPU上面执行。现在需要关注的信息</p>
<ul>
<li>1.Mapper Id<br>FC卡带上自带的额外扩展的芯片<strong>Mapper</strong>的id，后面再详细介绍。 </li>
<li>2.CHR-ROM/VROM<br>即Charater-ROM, 这部分就是存储的游戏中所需要用到的图像信息，或者换个说法，也就是常说的字体库。程序包那么小的体积，存图片肯定是不现实的，它是存储游戏中背景和精灵需要引用的图案的点阵，需要装载到显存。</li>
<li>3.PRG-ROM<br>即Program-ROM，这部分存储的就是游戏程序编译后的二进制代码，需要装载到主内存。</li>
<li>4.Mirroring-Type<br>镜像类型，主要是决定了程序运行过程显存中存储的背景渲染信息的那部分内存是如何规划，在PPU部分再详细解释。</li>
</ul>
<p>知道大概需要哪些东西了，就可以先定义一个获取该文件信息相关的接口了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INesLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 获取16KB PRG(程序)数据的页数</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPRGPageCount</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 获取8KB CHR(图像)数据的页数</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCHRPageCount</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 通过索引获取对应的PRG数据块</span></div><div class="line">    <span class="keyword">byte</span>[] getPRGPageByIndex(<span class="keyword">int</span> index);</div><div class="line"></div><div class="line">    <span class="comment">// 通过索引获取对应的CHR数据块</span></div><div class="line">    <span class="keyword">byte</span>[] getCHRPageByIndex(<span class="keyword">int</span> index);</div><div class="line"></div><div class="line">    <span class="comment">// 获取屏幕的镜像类型</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMirroringType</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMapperId</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">getFileMD5</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体文件格式可以看看这篇博客<br><a href="https://zhuanlan.zhihu.com/p/44035613" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/44035613</a></p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>FC使用的是2A03 CPU，主要在6502 CPU的基础上扩展了对音频处理(pAPU)的支持，所以CPU使用的其实仍是6502的汇编指令集。前面说过，模拟器主要模拟的是硬件，是FC程序的执行环境。FC程序也是直接使用的6502汇编进行的编程，不过它本身用什么也不重要，关键点在于编译后的程序最后是在什么硬件上运行的，因为编译后的都是二进制，我们需要解决的是把这些二进制机器码对应到CPU所支持的指令集，这样程序才能正常在该CPU上运行。(这里需要与Win上面的PE、Linux的ELF可执行文件区别开的是，Win和Linux上面编译后的程序虽然都是CPU可识别的机器码，但它们毕竟是运行在操作系统上，程序运行需要的资源的分配与管理、相应的系统调用都依赖该操作系统的内核，所以即使最终都是同一套机器码、在同样的硬件上面运行，也很难做到跨平台，重点在于这些程序需要另一套程序(内核)来进行管理)，而FC的程序不需要额外的管家，直接在硬件上面裸奔，所以直接将程序装载到主内存就可以跑了。因为要模拟CPU和内存，所以基本的思路就是对二进制的FC程序进行解释执行就可以了。接着先看看CPU直接访问的主内存各部分是怎么划分的</p>
<h3 id="主内存布局"><a href="#主内存布局" class="headerlink" title="主内存布局"></a>主内存布局</h3><p><img src="https://s1.ax1x.com/2020/05/29/tKYErt.png" alt="内存划分"></p>
<h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><p>实际就是程序运行期间可以完全供自己操作的内存，不过前面1kb(0-0x200)也是有固定用途的，ZeroPage指内存的第一页，临时存放一些数据，CPU可以用来快速寻址和执行；栈就是用来存放计算时需要临时保存的一些值，或者子程序(函数)调用和触发中断时需要将PC的下一条要执行指令的地址、状态寄存器等信息保存在栈中，等待执行完后再恢复现场; RAM(0x0200-0x0800)就是没有固定用途可任意操作的了。而0x0800-0x2000内存地址实际都是前面0-0x800的镜像，也就是说访问地址0x800实际是访问到了地址0，以此类推。所以可以看到，供程序自由发挥的也就2KB(0-0x0800)。</p>
<h4 id="I-O-Regesters"><a href="#I-O-Regesters" class="headerlink" title="I/O Regesters"></a>I/O Regesters</h4><p>0x2000-0x4020主要包含了PPU、APU(Audio Processing Unit)、手柄等输入设备的IO寄存器的内存映射，直接对映射的内存地址进行读写就可实现对这些设备的控制以及状态信息的获取。可以看到，前0x4020个字节对所有程序的内存都是这样规划的。</p>
<h4 id="Expansion-ROM-与-SRAM"><a href="#Expansion-ROM-与-SRAM" class="headerlink" title="Expansion ROM 与 SRAM"></a>Expansion ROM 与 SRAM</h4><p>Expansion ROM留作卡带程序的扩展空间;SRAM(Save RAM)主要用来给某些存在存档的游戏预留的空间，这两部分暂时都不用管。</p>
<h4 id="PRG-ROM"><a href="#PRG-ROM" class="headerlink" title="PRG-ROM"></a>PRG-ROM</h4><p>游戏卡带那部分提过，0x8000-0xFFFF这32KB空间用来存储游戏程序代码。</p>
<p>关于CPU，还有几点需要了解的。</p>
<ul>
<li>1.之前图已经给出了，2A03 CPU拥有16位的地址总线 ，可寻址的范围是2字节，即0x0000-0xFFFF，主内存总共空间大小为64KB，默认字节序采用<strong>小端序</strong>；而数据和控制总线都是8位的，所以具体操作内存的时候实际都是以字节为单位进行的。</li>
<li>2.实现CPU首先需要实现CPU的寄存器，寄存器主要包括PC(Program Counter)寄存器、SP(Stack Poninter)寄存器、A(Accumulator)累加器、X和Y索引寄存器以及处理器状态寄存器。栈指针寄存器就是始终指向当前栈顶的位置。CPU指令实现的过程中也需要对状态寄存器的标志位进行对应的改变。</li>
<li>3.寻址模式 ，也就是说看汇编指令(机器码)使用什么样的方式寻址，一共寻址模式包含10来种，也都是和机器码一起已经定义好的，至于程序使用哪种方式寻址程序开发人员自己发挥。所以具体实现时可以先完成各个寻址模式，然后再看各个指令的机器码分别对应哪种就行了。不管哪种寻址模式，最终目的都是拿到内存地址最终的数值，进行运算。这部分也纯粹是一个体力活，前面说过具体操作都以字节为单位，指令的机器码也是1字节，所以最多也只能有256个指令。实际6502CPU的指令只有几十个，剩下的要么是组合了不同的寻址模式(同一指令，寻址模式不同对应的机器码也不同)，要么是留作扩展。另外，指令包括官方指令和非官方指令，暂时实现官方记载的指令就可以支持大部分游戏了。根据文档，指令的排列还是有一定规律的，所以最好参照已有的模拟器代码来。测试可以写单元测试，可以用专门的测试Rom，倒比较好看执行结果。</li>
<li>4.时钟周期，既然模拟CPU，必须得控制好它的时钟周期。2A03CPU的主频才1.78MHz，要知道现在的CPU基本都是GHz起步了，这差了成百上千倍了，要是不加以控制，那么游戏里面指令执行的速度就会快到飞起，那样根本没法玩。所以运行过程中需要计算一下主频，首页要清楚的是主频(也称CPS, Cycle Per Second)实际是指<strong>CPU每秒度过的时钟周期数</strong>，一般一条指令需要1-几个时钟周期不等，看看以下的公式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">平均每个时钟周期花费的时间 = 1 / 每秒度过的时钟周期数</div><div class="line">程序运行时间 = CPU指令总的时钟周期数 * 每个周期花费的时间</div></pre></td></tr></table></figure>
</li>
</ul>
<p>所以要算出当前的主频<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">主频 = CPU指令总的时钟周期数 / 程序运行时间</div></pre></td></tr></table></figure></p>
<p>而CPU指令的周期数和程序运行的时间都是运行过程中需要进行统计的， 算出当前的主频后，直接一个While循环，当前的大于目标主频就直接sleep(),先空闲一段时间，接着计算。对于程序的主循环直接这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> time = System.nanoTime();</div><div class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            cpu.execute();</div><div class="line">            <span class="keyword">long</span> timeDiff = System.nanoTime() - time;</div><div class="line">            cps = cpu.getCycle() * <span class="number">1e9</span> / timeDiff;</div><div class="line">            <span class="keyword">while</span> (cps &gt; Emulator.TARGET_CPS) &#123;</div><div class="line">                sleep(<span class="number">1</span>);</div><div class="line">                cps = cpu.getCycle() * <span class="number">1e9</span> / (System.nanoTime() - time);</div><div class="line">            &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，应该也有了想法，一般的模拟器都有几倍加速的，其实加大下目标主频就行了，反正怎么调还是比现代的CPU速度慢得多。可以看看CPU执行的伪代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> opcode = mainMemory.readByte(register.getPC());</div><div class="line">        increasePC();</div><div class="line">        <span class="keyword">switch</span> (opcode) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> brk();</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>: xxx;</div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>: xxx;</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就是从内存读取操作码，然后对应到指令，如果指令还需要操作数，就继续在PC指向的地址取值，并移动PC指针到下一个地址。至于内存，因为多个地方要用到，所以也可以抽象出一个接口来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMemory</span> </span>&#123;</div><div class="line">    <span class="comment">// 从地址address读取1字节数据</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readByte</span><span class="params">(<span class="keyword">int</span> address)</span></span>;</div><div class="line">    <span class="comment">// 写1字节数据到地址address</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> address, <span class="keyword">int</span> value)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总的来说，CPU没有那么多弯弯绕绕，具体的指令无非就是一些基本的运算以及内存、寄存器的复制与读写，对着文档来就好。指令的实现参考<br><a href="http://nparker.llx.com/a2/opcodes.html" target="_blank" rel="external">http://nparker.llx.com/a2/opcodes.html</a><br><a href="https://wiki.nesdev.com/w/index.php/CPU_unofficial_opcodes" target="_blank" rel="external">https://wiki.nesdev.com/w/index.php/CPU_unofficial_opcodes</a><br><a href="http://www.6502.org/tutorials/6502opcodes.html" target="_blank" rel="external">http://www.6502.org/tutorials/6502opcodes.html</a></p>
<h2 id="PPU"><a href="#PPU" class="headerlink" title="PPU"></a>PPU</h2><p>PPU主要用来做图形渲染。要清楚图形是怎么渲染的，首先需要了解的是，以前的大头电视机是怎么工作的。借一张图看看<br><img src="https://pic4.zhimg.com/v2-12b0d40ad74d27ce6d8ff2499c6df163_b.webp" alt=""><br>图像其实是从屏幕左上角开始从左到右一个一个像素点进行渲染的，实际过程是电视机背后的电子枪发射出一个电子，而电视里面都是有一个大线圈，通电后产生了磁场，接着电子经过磁场的偏移打到了屏幕上的荧光材料从而产生了可见图形。而屏幕显示的彩色，是由红、绿、蓝RGB三基色进行混合。即三支电子枪发射出不同的电子，轰击到屏幕的三色荧光粉上，进行混合后就能产生不同的颜色。</p>
<p>图像经电子枪的扫描线从左到右渲染，一行完成后又要回到下一行的最左边，回到左边的这个时间段没有像素点被渲染，这个过程称为H-Blank(Horizontal Blank)。而整个屏幕被渲染完成后，又需要从右下角回到左上角开始绘制下一帧，这个时间段也没有像素点渲染，称为V-Blank(Vertical Blank)。FC的图像是以Tile(像素块)为基本单位的，一个Tile为8x8的像素块。<br>PPU有单独的一块显存VRAM(Video RAM)，接下来看看VRAM的内存布局</p>
<h3 id="VRAM内存布局"><a href="#VRAM内存布局" class="headerlink" title="VRAM内存布局"></a>VRAM内存布局</h3><p><img src="https://s1.ax1x.com/2020/05/30/tMgQ3R.png" alt="VRAM内存视图"></p>
<h4 id="调色板"><a href="#调色板" class="headerlink" title="调色板"></a>调色板</h4><p>即PaletteRAM indexes(0x3F00-0X3F1F)。系统调色板构成了FC能显示的64种颜色，而分别存储在VRAM中0x3F00-0x3F0F和0x3F10-0x3F1F(后面的0x3F20-0x3FFF都是镜像)位置的是16字节的背景调色板与16字节的Sprite调色板的索引，通过1字节来索引到系统调色板。调色板是在系统中写死的，不同模拟器颜色的差异也就是从这里来的。具体实现时，直接获取到调色板颜色对应的RGB值，再进行渲染。<br><img src="https://s1.ax1x.com/2020/05/30/tMjIQP.png" alt=""></p>
<h4 id="图案表-字体库"><a href="#图案表-字体库" class="headerlink" title="图案表(字体库)"></a>图案表(字体库)</h4><p>即PatternTable(0-0x2000)，图案表存储的是游戏中背景和Sprite需要用到的图案，分为两个4kb，由PPU的控制寄存器指定是给背景还是Sprite使用。图案表以16字节的方式步进的。看看下图，是冒险岛3首页的图案表<br><img src="https://s1.ax1x.com/2020/05/30/tQSrfH.png" alt=""><br>8x8的像素块一共64个像素点, 那如何确定像每个素点的颜色呢? 答案就是这16字节, 16字节分成2个8字节,即两个64位,从这两个64位各拿出1位来组成了4位中的低两位. 这里的4位是干啥用的呢?前面说过0x3F00-0x3F1F的两个16字节的调色板索引,用来索引到系统调色板. 所以对于背景与精灵的颜色,就需要用至少4位,(总共2^4=16)才能访问到这16字节. 整个过程就是</p>
<ul>
<li>1.用4位确定到调色板索引的地址</li>
<li>2.通过调色板索引的地址读取到1字节的调色板索引</li>
<li>3.最后再用该索引找到系统调色板中对应的颜色</li>
</ul>
<h4 id="名称表"><a href="#名称表" class="headerlink" title="名称表"></a>名称表</h4><p>即NameTable，FC总共有4个名称表,位于0x2000-0x2FFF，一共4kb，每个名称表占用1024字节。前面说过图像基本单位是8x8的像素块，FC使用的屏幕分辨率是256x240，刚好可以分成32x30个像素块，而名称表每1个字节存储的是像素块在图案表中的编号，总共需要32x30=960个字节。同样看看冒险岛3的名称表<br><img src="https://s1.ax1x.com/2020/05/30/tQplut.png" alt=""><br>上下个各2个名称表，问题来了，屏幕像素不是只有256x240，应该只要一个名称表就够了吧？这就是FC神奇的地方了，这样设计的目的是为了方便做屏幕滚动，现在的游戏屏幕滚动一般都是直接对同一块空间进行操作，也就是整块图像缓存空间重新刷新填充。而FC是直接通过修改PPU内部的寄存器在名称表上面进行偏移来达到滚动的效果，所以整块空间不需要频繁改动，后面再详细说明。最后剩余64个字节就是给属性表所使用的。</p>
<h4 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h4><p>属性表位于名称表的最后64字节，分成8x8个字节，前面说过分辨率是256x240, 除以8x8就是32x30，即属性表每1个字节分配给1个32x30的像素块。 而现在前面所说的4位还缺少2位,，这里1字节，分成4个2位, 于是将32x30的像素块再分成4块,可以分成4个8x8(实际有一个像素块不完整)的像素块,，每个8x8像素块就再使用图案表中的低2位+这个作为高2位，去确定到一个调色板索引的地址。到这里就可以发现了一个问题,，就是没办法为每个像素点确定到所有的调色版索引的地址，因为8x8像素块每个点中的高两位其实都是一样的，但前面说过了实际FC也是以8x8像素块为基本单位，确定了图案形状后，每个像素块中的像素点还能有几种变化就够了。另外，这里的属性表是给背景使用的，而精灵的属性表存储在<strong>SPR-RAM</strong>中。</p>
<h4 id="SPR-RAM"><a href="#SPR-RAM" class="headerlink" title="SPR-RAM"></a>SPR-RAM</h4><p>即Sprite-RAM，是PPU给精灵使用的单独一块256字节的空间，每个精灵占用4字节，也就是说屏幕上最多显示64个精灵。精灵是指的屏幕上面的活动块，比如游戏的角色或者状态栏一直需要变化的部分一般就是使用的多个精灵组合成的。看看马里奥就是由8个8x8的精灵像素块组成的<br><img src="https://s1.ax1x.com/2020/05/30/tQAMi6.png" alt=""><br>再看看4字节主要储存了哪些信息</p>
<ul>
<li>Byte0存储的是精灵左上角的y坐标-1。</li>
<li>Byte1存储了精灵像素块在图案表中的编号。</li>
<li>Byte2存储了资源信息<br>bit0-1存储的就是确定调色版索引地址的高2位<br>bit5决定了精灵的显示对于背景的优先级。<br>bit6表明精灵是否是要水平翻转<br>bit7表明精灵是否是要存储翻转</li>
<li>Byte3存储了精灵左上角的X坐标</li>
</ul>
<h3 id="PPU渲染"><a href="#PPU渲染" class="headerlink" title="PPU渲染"></a>PPU渲染</h3><p>前面介绍了相关的内存布局，现在来看看具体的渲染是怎样的。屏幕渲染的规则和采用的制式有关，FC大部分资料都是使用NTSC制式的，所以优先选取这个，毕竟对于了解工作原理来说，这都不是重点。渲染过程中，每帧扫描线一个有262条，每秒渲染60帧。</p>
<ul>
<li>0-239这240条是屏幕上可见的扫描线(屏幕是256x240分辨率，高为240)，在这个过程中需要进行屏幕像素的渲染。</li>
<li>240-260为V-Blank，这个时间段是不可见扫描线，主要用来生成nmi、获取手柄的状态信息、为下一帧的渲染做好准备。</li>
<li>第261条是预处理扫描线，在这个扫描线开始时需要结束V-Blank，清除其它的一些状态信息。这条扫描线和可见扫描线一样需要更新相关的寄存取信息，但不做任何像素的渲染。<h4 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h4>每条扫描线一共需要花费341个PPU时钟周期，而1CPU周期=3PPU周期。这里就需要与CPU周期进行同步了，同步有很多种方式，可以直接渲染完一条扫描线，CPU就走341/3个时钟周期；或者渲染完一帧，CPU走261*341/3个时钟周期。采用精度最高的方式就是走1个CPU周期，PPU走3个时钟周期。每个周期渲染一个像素点，当然按照tile也就是1行8个像素点为单位来渲染比较方便，每隔8个时钟周期，一次渲染8个像素点。屏幕宽是256个像素点，渲染完背景的一行就需要256个时钟周期，接下来257-320是HBlank，也可以不进行任何渲染，再往后可以提前渲染下一行的前两个8像素的块。完整的渲染过程</li>
<li>1.抓取当前渲染到的像素块的编号(当前屏幕左上角名称表地址+当前位置在屏幕内像素块个数的偏移)，用编号去获取到图案表中的像素块(16字节步进)。</li>
<li>2.像素块是8x8，所以还要获取到当前扫描线在8x8像素块里面偏移的行和列是多少。这样就可以获取到像素点的低2位。</li>
<li>3.抓取当前像素块所在资源表的地址，获取到高2位，与前面的低2位一起就能组合出调色板索引的地址，最后根据调色板索引获取到系统调色板的RGB值。</li>
</ul>
<h4 id="PPU滚动"><a href="#PPU滚动" class="headerlink" title="PPU滚动"></a>PPU滚动</h4><p>上面所述的偏移，其实就是PPU实现屏幕滚动的关键，下图来自NesDev<br><img src="http://wiki.nesdev.com/w/images/b/bf/NTS_scrolling_seam.gif" alt="屏幕滚动"><br>滚动其实就是修改在名称表上面的偏移来进行的，具体实现时按理来说可以直接根据PPU寄存器的内存映射来(0x2000-0x2007)，但关键在于游戏程序不按你想的来，就会出现需要抓取的资源没有更新。可以看看这篇博客<br><a href="https://gridbugs.org/zelda-screen-transitions-are-undefined-behaviour/" target="_blank" rel="external">https://gridbugs.org/zelda-screen-transitions-are-undefined-behaviour/</a></p>
<p>所以最佳的方式是实现PPU内部的寄存器v、t、x、w，在进行PPU的内存映射地址操作过程中对这几个寄存器进行维护即可。接下来看看这几个寄存器</p>
<ul>
<li>v: 当前的VRAM地址。</li>
<li>t: 临时的VRAM地址，也可以被看作是屏幕窗口左上角的地址。</li>
<li>x: 精准x滚动(3bit)。</li>
<li>w: 第一次或第二次写时触发(1bit)。</li>
</ul>
<p>CPU使用主内存的0x2007读写数据时，PPU使用的就是当前的VRAM地址，它也被用来获取名称表的数据以绘制到屏幕上。在用名称表的数据进行渲染时，也会更新当前的VRAM地址，保证获取的数据是正确的。v和t寄存器由15位组成</p>
<ul>
<li>0-4bit:  模糊x滚动(名称表中当前像素块位置的x轴偏移)。</li>
<li>5-9bit: 模糊y滚动(名称表中当前像素块位置的y轴偏移)。</li>
<li>10-11bit: 名称表选择。</li>
<li>12-14bit:  精准Y轴滚动。</li>
</ul>
<p>而x寄存器和v、t寄存器的12-14bit就是当前通过名称表的像素块编号找到的8x8像素块具体的像素点偏移的位置。知道了这几个，剩下的直接根据wiki来就可以了<br><a href="http://wiki.nesdev.com/w/index.php/PPU_scrolling" target="_blank" rel="external">http://wiki.nesdev.com/w/index.php/PPU_scrolling</a></p>
<p>具体渲染的时候将当前屏幕每个像素点的RGB值放到一个缓冲区，一帧填充完后，再交给系统的api进行绘制。至于精灵的渲染，过程也是一样的，只是精灵的渲染要完全按照文档来，还是有些繁琐了，而且文档有些地方语焉不详，见过其它几个模拟器也都是不同的实现。之前的做法是直接在预渲染扫描线填充到缓冲区一次，大部分游戏都没有问题，直到忍者神龟2，精灵没有显示出来，后面发现原因是精灵的图案表在可见扫描线渲染过程中才填充，按理来说一般图案表在一帧渲染前提前准备好了，但这游戏偏偏不这么干就没办法了，解决部分就是在可见扫描线再进行精灵像素的拉取。PPU这一块主要关键点就这些了。</p>
<h2 id="APU"><a href="#APU" class="headerlink" title="APU"></a>APU</h2><p>即Audio Processing Unit，音频处理单元实际是2A03CPU的一部分，不过实现时还是当作单独的硬件。要实现声音处理的硬件，还是要先清楚声音是怎样产生和传播的。人耳能听到声音是因为物体振动影响到了空气的波动，进而影响到了耳膜振动，接着耳膜发出信号传输到大脑的听觉神经，这样人就感知到了声音。对于计算机，因为只能识别二进制，想要听到人的声音，首先是人肺部流出的空气影响到声带的振动，带动空气的振动，从而影响到麦克风等设备内部的声音传感器内的薄膜振动导致产生了电压的变化，这样也就把自然界中的模拟信号转换成了计算机可以识别的电信号（数字信号）。可以看到，这个过程中计算机只是感知到了信号的变化，但它根本不知道这是干嘛的。所以还是由人来控制，将计算机收集到的信号保存下来。接着将保存的电信号再传输到音响等设备。以扬声器为例，电信号使得线圈通过电流后产生了磁场，而设备一般会携带一个固定的磁铁，两个磁场互相作用影响了线圈的振动，最后使与线圈连接在一起的鼓膜振动发出了声音。然后看看实现APU模块需要的过程。</p>
<ul>
<li>1.将几个声音通道产生的数字信号转换为模拟信号-&gt;混音器混合模拟信号产生声音<br>如果是原来的硬件到这里就完了，但模拟器还需要一个过程，因为不同音频设备驱动方面都有较大差异，所以也没办法简单的直接使用自己的硬件输出声音。</li>
<li>2.对混音器输出的模拟信号进行采集(当然这个模拟信号也是直接根据公式算出的0.0-1.0之间的小数，不算真正意义的模拟信号)。也就是一个完整的【采样-&gt;量化-&gt;编码】，因为模拟信号是在一段连续的时间里不停的产生，采样就是在这断时间内间隔的采集声音样本，将时间离散化；接着就是量化，采集到的声音在相邻的样本之间，声音的幅度还是可以有无数个，所以需要将幅度也进行离散化，也就是将声音的幅度变化控制在一个具体有限的范围内；最后就是编码，也就是将样本按特定的规则组织。这样采集到的数据就可以交给本机的硬件去进行播放了。</li>
</ul>
<p>具体到FC，一共有5个声音通道，2个方波(Pulse)、1个三角波(Triangle)、1个噪音(Noise)、1个增量调整通道(DMC)。方波和三角波用来控制游戏的背景声音和主旋律，噪音一般用作打击音效，DMC可以用来输出DPCM的声音样本，一般用作特殊音效。</p>
<h4 id="时钟周期-1"><a href="#时钟周期-1" class="headerlink" title="时钟周期"></a>时钟周期</h4><p>同样模拟硬件少不了的就是时钟的控制，APU里面各个组件用的比较多的是Divider，可以把它当作一个定时器，倒计时完成后，会触发各个组件内部产生一个时钟周期的变化。APU内部有一个帧计数器(Frame Counter)，用来控制其它组件的时钟周期，注意不要和图形渲染的帧搞混了，两者没有关系。一帧为14915/18641(取决于寄存器的控制位是4步还是5步模式)个APU周期，而1APU周期=2CPU周期，所以整个APU还是跟随着CPU指令的执行来进行时钟周期的控制。至于其它的，文档基本写得挺详细了，就不多说了。<br><a href="https://wiki.nesdev.com/w/index.php/APU" target="_blank" rel="external">https://wiki.nesdev.com/w/index.php/APU</a></p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>前面说过，CPU其实就相当于一个死循环，通电后总是在做【取指令-&gt;指令译码-&gt;执行指令】这样重复的过程。 CPU内部的指令指针寄存器PC保存的就是下一条要执行的指令的地址。那问题来了，程序该怎么把起始地址信息告诉CPU呢？答案就是中断。首先必须明确的，机器再高级始终是机器，只会按固定的规则办事。对于6502CPU，通电启动时会主动触发一个RESET中断，接着CPU会从固定的内存地址来读取中断处理程序并把该地址放到PC寄存器，所以只要在这个地方保存程序加载到内存后的起始地址，接下来CPU就会从程序的起始地址开始执行。直接按字面意思，中断就是打断当前执行的指令。</p>
<p>6502中断一共有4种，RESET、IRQ、BRK、NMI。RESET前面已经说过了。IRQ一般是硬件所产生的，比如APU(音频处理单元)、Mapper（游戏卡带上面携带的用来作内存映射的额外芯片），可通过设置CPU的标志位来屏蔽；BRK一般是软件所产生的中断，对应着6502汇编指令BRK；NMI(No-Maskable Interrupt )不可屏蔽中断，是在PPU的不可见扫描线期间即V-Blank时产生的，可通过设置PPU的控制寄存器进行屏蔽。</p>
<p>不同的中断实际是有额外的引脚连接到CPU的，但我们这里是模拟硬件，不用管这些，只实现发送中断时要做的事情就可以了。从硬件层面来说，CPU执行指令的时候，其它的硬件可以直接通过不同的线路发送信号给CPU，其它硬件的工作以及产生中断更像是并行的，用多线程模拟合理一点，但这就增加了编码的难度。而现在的CPU速度已经比6502高了成百上千倍了，使用单线程模拟完全没任何问题，只需要每次执行指令前检查一下是否有新的中断即可。 另外，因为中断产生时需要打断当前CPU下一条要执行的指令，和函数调用一样，所以程序中一般会先保存当前的PC、状态寄存器等信息到内存，等中断程序完成后再回到之前的位置。</p>
<h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><p>以前的FC游戏从主内存0x8000-0xFFFF，显存0-0x1FFF，顶多就只能存储40kb程序相关的资源了，早期的游戏也确实够了。但可以了解到的是，后面的一些游戏，无论是声音，游戏的画面，游戏丰富的内容，这些只有40kb是远不够的。但FC硬件也固定了，所以后面任天堂就提供了游戏卡带的扩展，称为Mapper。也就是说游戏卡带上有额外的一个芯片来进行内存映射，对于CPU和PPU来说，看到的内存空间始终那么大，但Mapper可以进行内存切换，也就是在某个时刻，将原来分配好的内存地址的程序或者图案表切换成卡带上面其它的，这样就解决了40kb的限制。这一做法，使得FC游戏的体验大大的提升，有些卡带更是会扩展音源。Mapper大概有两百多种，不过一些是某个Mapper的变种。FC也满足二八原则，实现少量的Mapper就可以兼容大部分游戏了，游戏占比比较大的就是Mapper0-4了。</p>
<h2 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h2><p>其它组件都已经实现了，输入设备肯定不能少，不然游戏都玩不起来。输入设备实际也是经过内存映射IO寄存器到0x4016和0x4017，分别对应玩家1和玩家2。游戏读取手柄的状态，是定期地按照手柄顺序A、B、选择、开始、上、下、左、右不断的获取8个按键按下的状态。所以实现普通的手柄控制，只需要用额外的空间存储8个按键的状态，按下是1，释放是0，最后将键盘上的按键映射到手柄的按键即可。参考<br><a href="https://wiki.nesdev.com/w/index.php/Standard_controller" target="_blank" rel="external">https://wiki.nesdev.com/w/index.php/Standard_controller</a></p>
<p><a href="https://wiki.nesdev.com/w/index.php/Controller_reading_code" target="_blank" rel="external">https://wiki.nesdev.com/w/index.php/Controller_reading_code</a></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>写模拟器毕竟不像普通的程序，调试起来还是没那么容易的。所以可以实现一个辅助的6502汇编指令调试器进行调试，主要就是将一块程序内存的机器码反汇编成6502汇编程序，再实现名称表、图案表、SpriteRAM的可视化以及内存的dump。<br><img src="https://s1.ax1x.com/2020/06/02/tYpCTA.png" alt=""></p>
<h4 id="存档与读档"><a href="#存档与读档" class="headerlink" title="存档与读档"></a>存档与读档</h4><p>以前玩真机，毕竟头疼的是，有些游戏关卡太长或者难度太大，就经常玩不到最后，电源就发热严重了或者游戏机会偶尔抽风，一断电啥都没有了，每次都得重来。所以自己实现模拟器，存档与读档是肯定是必须的。所谓存档，实际就是把当前的内存保存现场，读档就是恢复现场。具体到FC，主要就是把主内存、VRAM与各个硬件的寄存器状态、以及绘图用到的缓冲区、Mapper都存储下来。只是直接暴力的存储占用空间有点大，一个游戏才几十k，存档却多好几倍了，不过对于现在的机器来说这点空间完全无关紧要。</p>
<h4 id="画质增强"><a href="#画质增强" class="headerlink" title="画质增强"></a>画质增强</h4><p>这也是一个比较令人头疼的问题，FC使用的不过是256x240分辨率的屏幕，而现在的屏幕基本1、2k分辨率起了，强行地拉伸像素块边缘就会有明显的方块感，这可不是我们的童年。经过调研，发现比较可靠实用的就是xBRZ图像缩放算法，整体还是不错的。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>对于实现一个模拟器，主要就是对硬件要有足够的理解，控制好各个组件之间时钟周期的同步，通过以前的这么一个平台，也可以一窥现在一些平台的工作。原理了解了，具体的实现过程中可以有多种不同的方式。对于FC，由于硬件本身的资料不是完全开放的，而且比较有意思的是实现Mapper的时候，几个不同地方的文档有不同的实现。不过总有一些游戏你不知道会使用哪些奇葩特性，所以很难有模拟器能完美支持所有的游戏，一些模拟器也不是完全模拟硬件，对特殊的游戏会使用一些trick，不过这些对理解平台的工作都无关紧要了。更多资料，英文基本就NesDev了，里面有个不算长的NesDoc写得还可以。<br><a href="http://nesdev.com/NESDoc.pdf" target="_blank" rel="external">http://nesdev.com/NESDoc.pdf</a><br>然后下面是我找得到的有用的中文资料。<br><a href="http://rexq.me/2020/03/22/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAFC%E6%A8%A1%E6%8B%9F%E5%99%A8/" target="_blank" rel="external">http://rexq.me/2020/03/22/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAFC%E6%A8%A1%E6%8B%9F%E5%99%A8/</a><br><a href="https://www.cnblogs.com/chunyueye/p/12261027.html" target="_blank" rel="external">https://www.cnblogs.com/chunyueye/p/12261027.html</a><br><a href="https://zhuanlan.zhihu.com/p/34144965" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34144965</a><br><a href="https://zhuanlan.zhihu.com/p/43999178" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/43999178</a><br><a href="https://blog.chaofan.io/archives/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9Cnes%E6%A8%A1%E6%8B%9F%E5%99%A8" target="_blank" rel="external">https://blog.chaofan.io/archives/如何制作nes模拟器</a><br><a href="http://www.360doc.com/content/18/0116/09/33564766_722316244.shtml" target="_blank" rel="external">http://www.360doc.com/content/18/0116/09/33564766_722316244.shtml</a></p>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p>纯属好玩</p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">扫码打赏，你说多少就多少</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/alipay.png" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/weixin.png" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){
            
            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/06/02/实现一个FC模拟器/">实现一个FC模拟器</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Legend 的个人博客">Legend</a></p>
        <p><span>发布时间:</span>2020年06月02日 - 11时42分</p>
        <p><span>最后更新:</span>2020年06月12日 - 23时30分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/06/02/实现一个FC模拟器/" title="实现一个FC模拟器">http://blog.cspojie.cn/2020/06/02/实现一个FC模拟器/</a>
            <span class="copy-path" data-clipboard-text="原文: http://blog.cspojie.cn/2020/06/02/实现一个FC模拟器/　　作者: Legend" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
  
    <a href="/2020/01/01/回首2019/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">回首2019</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总览"><span class="toc-number">2.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#游戏卡带"><span class="toc-number">3.</span> <span class="toc-text">游戏卡带</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU"><span class="toc-number">4.</span> <span class="toc-text">CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主内存布局"><span class="toc-number">4.1.</span> <span class="toc-text">主内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RAM"><span class="toc-number">4.1.1.</span> <span class="toc-text">RAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-Regesters"><span class="toc-number">4.1.2.</span> <span class="toc-text">I/O Regesters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Expansion-ROM-与-SRAM"><span class="toc-number">4.1.3.</span> <span class="toc-text">Expansion ROM 与 SRAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PRG-ROM"><span class="toc-number">4.1.4.</span> <span class="toc-text">PRG-ROM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PPU"><span class="toc-number">5.</span> <span class="toc-text">PPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VRAM内存布局"><span class="toc-number">5.1.</span> <span class="toc-text">VRAM内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调色板"><span class="toc-number">5.1.1.</span> <span class="toc-text">调色板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图案表-字体库"><span class="toc-number">5.1.2.</span> <span class="toc-text">图案表(字体库)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#名称表"><span class="toc-number">5.1.3.</span> <span class="toc-text">名称表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性表"><span class="toc-number">5.1.4.</span> <span class="toc-text">属性表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPR-RAM"><span class="toc-number">5.1.5.</span> <span class="toc-text">SPR-RAM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PPU渲染"><span class="toc-number">5.2.</span> <span class="toc-text">PPU渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时钟周期"><span class="toc-number">5.2.1.</span> <span class="toc-text">时钟周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PPU滚动"><span class="toc-number">5.2.2.</span> <span class="toc-text">PPU滚动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APU"><span class="toc-number">6.</span> <span class="toc-text">APU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时钟周期-1"><span class="toc-number">6.0.1.</span> <span class="toc-text">时钟周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断"><span class="toc-number">7.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mapper"><span class="toc-number">8.</span> <span class="toc-text">Mapper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入设备"><span class="toc-number">9.</span> <span class="toc-text">输入设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">10.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调试"><span class="toc-number">10.0.1.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#存档与读档"><span class="toc-number">10.0.2.</span> <span class="toc-text">存档与读档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#画质增强"><span class="toc-number">10.0.3.</span> <span class="toc-text">画质增强</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结尾"><span class="toc-number">11.</span> <span class="toc-text">结尾</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <div id="gitments"></div>
<script src="/js/gitment.browser.js"></script>
<script src="https://www.wenjunjiang.win/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
      id: window.decodeURIComponent(window.location.pathname),
      owner: 'Xchuanshuo',
      repo: 'Xchuanshuo.github.io',
      oauth: {
        client_id: '84a8ba9556b4d1293665',
        client_secret: 'f6ce30da75414de93e37eb4a59102fbcb53ea568',
      },
    })
    gitment.render('gitments')
</script>
    



    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2020/01/01/回首2019/" title="下一篇: 回首2019">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/02/实现一个FC模拟器/">实现一个FC模拟器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/01/回首2019/">回首2019</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/Tomcat剖析之源码篇-二/">Tomcat剖析之源码篇(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/14/Tomcat剖析之架构篇(一)/">Tomcat剖析之架构篇(-)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/回首2018/">回首2018</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/JVM运行期优化/">JVM运行期优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/30/LRU与LFU缓存算法/">LRU与LFU缓存算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/平衡查找树之AVL树/">平衡查找树之AVL树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/16/Manacher算法求解最长回文子串/">Manacher算法求解最长回文子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/15/Java内存模型/">Java内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/02/Linux也可以这样美——Ubuntu18-04安装、配置、美化-踩坑记/">Linux也可以这样美——Ubuntu18.04安装、配置、美化-踩坑记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/JVM中的类加载机制/">JVM中的类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/08/坦白说解密/">坦白说解密</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/29/Java内存区域与内存溢出/">Java内存区域与内存溢出</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/13/仿MIUI实现带弹性的ScrollView/">仿MIUI实现带弹性的ScrollView</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/09/机器学习起步－k-最近邻算法/">机器学习起步－k-最近邻算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/14/Okhttp3的封装-搞定常用的请求/">Okhttp3的封装 搞定常用的请求</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/10/实现安卓无限轮播组件Banner/">实现安卓无限轮播组件Banner</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/31/浅谈Android中的MVP架构/">浅谈Android中的MVP架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/随机模拟算法求解圆周率/">随机模拟算法求解圆周率</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/21/Android第三方登录与服务器端验证过程/">Android第三方登录与服务器端验证过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/10/Django查错配置/">Django查错配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/04/Ubuntu16-04下Nginx-uwsgi部署Django项目/">Ubuntu16.04下Nginx+uwsgi部署Django项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/回首2017-展望未来/">回首2017 展望未来</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/Pycahrm远程调试Django项目/">Pycahrm远程调试Django项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/Python中的策略模式/">Python中的策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/图论-应用篇/">图论 应用篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/MySQL性能优化-一/">MySQL性能优化(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/20/图论-基础篇/">图论 基础篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/二叉堆与优先队列/">二叉堆与优先队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/06/Ubuntu下常用命令汇总/">Ubuntu下常用命令汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/02/分治思想之排序算法/">分治思想之排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/灵活-高效的符号表-二叉查找树/">灵活&&高效的符号表--二叉查找树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/Python3爬取百科词条-导入MySQL数据库/">Python3爬取百科词条+导入MySQL数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/常用的正则表达式整理/">常用的正则表达式整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/面向对象思想/">面向对象思想</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/25/玩转Python装饰器/">玩转Python装饰器</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>

 </div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 Legend
            </div>
            <div class="footer-right">
                
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >geek到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>