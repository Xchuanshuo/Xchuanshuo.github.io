<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tomcat剖析之源码篇(二) | legend＇s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言前面第一篇介绍了Tomcat的整体架构，能让我们在宏观上对Tomcat的运转流程有一个认识，但原理毕竟只是理论，这篇博客就来从源码入手，分析Tomcat的的初始化、启动、各个组件的构建、一次请求的分发、生命周期的管理等内容。">
<meta name="keywords" content="Tomcat,Java,源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat剖析之源码篇(二)">
<meta property="og:url" content="http://blog.cspojie.cn/2019/08/12/Tomcat剖析之源码篇-二/index.html">
<meta property="og:site_name" content="legend＇s blog">
<meta property="og:description" content="前言前面第一篇介绍了Tomcat的整体架构，能让我们在宏观上对Tomcat的运转流程有一个认识，但原理毕竟只是理论，这篇博客就来从源码入手，分析Tomcat的的初始化、启动、各个组件的构建、一次请求的分发、生命周期的管理等内容。">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3110248-be5dca1e75b94dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3110248-1f9172eb7f189347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3110248-2acfdd9e90e978f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3110248-28ba9586ba4a065d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3110248-8177e7af61f0139b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3110248-9d45a004095f4b44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3110248-8f324232291f4d0c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50">
<meta property="og:updated_time" content="2019-08-12T06:34:34.593Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tomcat剖析之源码篇(二)">
<meta name="twitter:description" content="前言前面第一篇介绍了Tomcat的整体架构，能让我们在宏观上对Tomcat的运转流程有一个认识，但原理毕竟只是理论，这篇博客就来从源码入手，分析Tomcat的的初始化、启动、各个组件的构建、一次请求的分发、生命周期的管理等内容。">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/3110248-be5dca1e75b94dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternative" href="/atom.xml" title="legend＇s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Legend</a></h1>
        </hgroup>

        
        <p class="header-subtitle">最大的幸运是年轻时有着对梦想执着的激情</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/about">留言打卡</a></li>
                        
                            <li><a href="/FrontEndGuide">后端导航</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="/2414605975@gmail.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/Xchuanshuo" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                            
                                <a class="fl google" target="_blank" href="/aixs241460@gmail.com" title="google">google</a>
                            
                                <a class="fl linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Android/" style="font-size: 18.33px;">Android</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Java/" style="font-size: 11.67px;">Java</a> <a href="/tags/Linux/" style="font-size: 16.67px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Python/" style="font-size: 18.33px;">Python</a> <a href="/tags/Tomcat/" style="font-size: 11.67px;">Tomcat</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/图/" style="font-size: 11.67px;">图</a> <a href="/tags/字符串匹配/" style="font-size: 10px;">字符串匹配</a> <a href="/tags/常用命令/" style="font-size: 10px;">常用命令</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/架构/" style="font-size: 10px;">架构</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/源码分析/" style="font-size: 11.67px;">源码分析</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/算法与数据结构/" style="font-size: 20px;">算法与数据结构</a> <a href="/tags/编程思想/" style="font-size: 10px;">编程思想</a> <a href="/tags/设计模式/" style="font-size: 11.67px;">设计模式</a> <a href="/tags/随笔/" style="font-size: 13.33px;">随笔</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jikedaohang.com/">极客导航</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.ofmonkey.com/">在线工具</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">虽生有涯而知无涯，但进一寸有一寸的欢喜！</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Legend</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Legend</a></h1>
            </hgroup>
            
            <p class="header-subtitle">最大的幸运是年轻时有着对梦想执着的激情</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/about">留言打卡</a></li>
                
                    <li><a href="/FrontEndGuide">后端导航</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="/2414605975@gmail.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/Xchuanshuo" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                    
                        <a class="google" target="_blank" href="/aixs241460@gmail.com" title="google">google</a>
                    
                        <a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-Tomcat剖析之源码篇-二" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/12/Tomcat剖析之源码篇-二/" class="article-date">
      <time datetime="2019-08-12T06:29:31.000Z" itemprop="datePublished">2019-08-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Tomcat剖析之源码篇(二)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Tomcat/">Tomcat</a><a class="article-category-link" href="/categories/Tomcat/Java/">Java</a><a class="article-category-link" href="/categories/Tomcat/Java/源码分析/">源码分析</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tomcat/">Tomcat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面第一篇介绍了Tomcat的整体架构，能让我们在宏观上对Tomcat的运转流程有一个认识，但原理毕竟只是理论，这篇博客就来从源码入手，分析Tomcat的的初始化、启动、各个组件的构建、一次请求的分发、生命周期的管理等内容。<a id="more"></a></p>
<h2 id="从初始化开始"><a href="#从初始化开始" class="headerlink" title="从初始化开始"></a>从初始化开始</h2><p>Tomcat启动有三种方式，第一种是直接通过<strong>org.apache.catalina.startup.Bootstrap</strong>类的main方法，这也是最早出现的一种方式，需要自己去配置server.xml文件;第二种是通过内嵌的方式,现在比较流行的SpringBoot也就是内嵌的<strong>org.apache.catalina.startup.Tomcat</strong>类;第三种是使用脚本，这里对应的是Tomcat根目录的bin目录下的startup.sh(Windows下面是startup.bat, 其它一样)脚本文件开始的，像早期的web项目、ssm这些开发和部署都是使用的这种方式，这个脚本文件主要做的事情就是设置一些环境变量，然后会调用<strong>catalina.sh</strong>文件，这几种方式做的都是同样的事，会先获取一些初始化参数。其实不管哪种方式，最终还是都会到Java类，走一样的流程。<strong>Bootstrap</strong>类首先会调用<strong>init()</strong>方法，看下面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">     ......</div><div class="line">     Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>);</div><div class="line">     Object startupInstance = startupClass.getConstructor().newInstance();</div><div class="line">     String methodName = <span class="string">"setParentClassLoader"</span>;</div><div class="line">     Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</div><div class="line">     paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">"java.lang.ClassLoader"</span>);</div><div class="line">     Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">     paramValues[<span class="number">0</span>] = sharedLoader;</div><div class="line">     Method method =</div><div class="line">         startupInstance.getClass().getMethod(methodName, paramTypes);</div><div class="line">     <span class="comment">// 调用Catalina类的setParentClassLoader方法</span></div><div class="line">     method.invoke(startupInstance, paramValues);</div><div class="line">     <span class="comment">// 把实例化的对象赋值给该变量，后面需要用到</span></div><div class="line">     catalinaDaemon = startupInstance;</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><strong>Bootstrap类会</strong>会通过反射的方式调用<strong>Catalina类的</strong>的<strong>setParentClassLoader()</strong>方法，设置当前<strong>Server</strong>的扩展类加载器，接着看看Bootstrap类main方法接下来的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// daemon就是Bootstrap类的实例</span></div><div class="line">daemon.load(args);</div><div class="line">daemon.start();</div></pre></td></tr></table></figure></p>
<p>这就是在根据初始化的命令参数的进行后续的操作,  首先会调用<strong>load()</strong>方法, 这个方法同样是以反射方式调用<strong>Catalina</strong>类的load方法，这是个比较重要的方法，看看源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</div><div class="line">        ......</div><div class="line">        <span class="comment">// Create and execute our Digester</span></div><div class="line">        Digester digester = createStartDigester();</div><div class="line"></div><div class="line">        InputSource inputSource = <span class="keyword">null</span>;</div><div class="line">        InputStream inputStream = <span class="keyword">null</span>;</div><div class="line">        File file = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// 读取server.xml文件</span></div><div class="line">                file = configFile();</div><div class="line">                inputStream = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">                inputSource = <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">                    log.debug(sm.getString(<span class="string">"catalina.configFail"</span>, file), e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    inputStream = getClass().getClassLoader()</div><div class="line">                        .getResourceAsStream(getConfigFile());</div><div class="line">                    inputSource = <span class="keyword">new</span> InputSource</div><div class="line">                        (getClass().getClassLoader()</div><div class="line">                         .getResource(getConfigFile()).toString());</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">                        log.debug(sm.getString(<span class="string">"catalina.configFail"</span>,</div><div class="line">                                getConfigFile()), e);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// server.xml为空则读取server-embed.xml文件</span></div><div class="line">            <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    inputStream = getClass().getClassLoader()</div><div class="line">                            .getResourceAsStream(<span class="string">"server-embed.xml"</span>);</div><div class="line">                    inputSource = <span class="keyword">new</span> InputSource</div><div class="line">                    (getClass().getClassLoader()</div><div class="line">                            .getResource(<span class="string">"server-embed.xml"</span>).toString());</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">                        log.debug(sm.getString(<span class="string">"catalina.configFail"</span>,</div><div class="line">                                <span class="string">"server-embed.xml"</span>), e);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">          ......</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                inputSource.setByteStream(inputStream);</div><div class="line">                digester.push(<span class="keyword">this</span>);</div><div class="line">                digester.parse(inputSource);</div><div class="line">            &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</div><div class="line">                log.warn(<span class="string">"Catalina.start using "</span> + getConfigFile() + <span class="string">": "</span> +</div><div class="line">                        spe.getMessage());</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                log.warn(<span class="string">"Catalina.start using "</span> + getConfigFile() + <span class="string">": "</span> , e);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    inputStream.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    <span class="comment">// Ignore</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        <span class="comment">// Start the new server</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            getServer().init();</div><div class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</div><div class="line">            <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                log.error(<span class="string">"Catalina.start"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看到第一行会调用<strong>createDigester()</strong>方法创建一个Digester对象的实例，那么这个对象是干嘛的呢？<strong>用来解析xml文件，将xml里面配置的属性映射到对应的Java对象</strong>，看看这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Digester <span class="title">createStartDigester</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Initialize the digester</span></div><div class="line">        Digester digester = <span class="keyword">new</span> Digester();</div><div class="line">        ......</div><div class="line">        <span class="comment">// Configure the actions we will be using</span></div><div class="line">        digester.addObjectCreate(<span class="string">"Server"</span>,</div><div class="line">                                 <span class="string">"org.apache.catalina.core.StandardServer"</span>,</div><div class="line">                                 <span class="string">"className"</span>);</div><div class="line">        digester.addSetProperties(<span class="string">"Server"</span>);</div><div class="line">        <span class="comment">// 调用栈顶对象的setServer()方法注入一个实现了Server接口的StandardServer实现类</span></div><div class="line">        digester.addSetNext(<span class="string">"Server"</span>,</div><div class="line">                            <span class="string">"setServer"</span>,</div><div class="line">                            <span class="string">"org.apache.catalina.Server"</span>);</div><div class="line"></div><div class="line">        digester.addObjectCreate(<span class="string">"Server/Listener"</span>,</div><div class="line">                                 <span class="keyword">null</span>, <span class="comment">// MUST be specified in the element</span></div><div class="line">                                 <span class="string">"className"</span>);</div><div class="line">        digester.addSetProperties(<span class="string">"Server/Listener"</span>);</div><div class="line">        digester.addSetNext(<span class="string">"Server/Listener"</span>,</div><div class="line">                            <span class="string">"addLifecycleListener"</span>,</div><div class="line">                            <span class="string">"org.apache.catalina.LifecycleListener"</span>);</div><div class="line"></div><div class="line">        digester.addObjectCreate(<span class="string">"Server/Service"</span>,</div><div class="line">                                 <span class="string">"org.apache.catalina.core.StandardService"</span>,</div><div class="line">                                 <span class="string">"className"</span>);</div><div class="line">        ......</div><div class="line">        <span class="keyword">return</span> digester;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个方法首先直接实例化一个<strong>Digester对象</strong>, 接着主要是用来解析<strong>server.xml文件</strong>，该文件不存在时再获取其它的配置文件，这里看源码就很容易清楚了, 这个方法里面定义了一系列的解析规则，使用这些规则经能把需要的属性注入到对应的Java对象实例，再回到<strong>load()方法</strong>，里面有这么一行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">digester.push(<span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p>Digester对象内部维护了一个栈，这行代码就是push当前<strong>Catalina对象到Digester内部维护的栈的栈顶</strong>。以Server的注入为例，这里就是首先用<strong>digester.addObjectCreate()方法</strong>查看xml文件中Server标签中的className属性是否为空,为空则实例化一个<strong>StandardServer</strong>对象，并把此对象push到栈顶，然后使用<strong>digester.addSetProperties()</strong>方法设置在配置文件中与它相关的属性,最后再使用 <strong>digester.addSetNext()</strong>方法，拿到当前栈顶元素的下一层的元素，在这里也就是Catalina对象,然后调用它的<strong>setServer()</strong>方法把当前栈顶元素当作参数传入，这样一来当前<strong>Catalina的Server已经实例好了</strong>。栈顶存放的始终是上一层的实例化对象, 解析到的当前层级的xml标签如果还有下一层，继续按照配置好的规则进行解析，层层递进，用这种方式，就可以将Tomcat各个组件的一些属性或它的子组件装配好。再回到<strong>load()方法</strong>，解析完xml文件后最终会调用 <strong>getServer().init()</strong>方法，这个Server也就是前面实例化好的<strong>StandardServer</strong>，直接跟进去看看它的<strong>init()方法</strong>,结果发现这个方法是在它的父类<strong>LifecycleBase</strong>实现的，而这个类看名字就知道是和生命周期有关的，所以引出了下面的内容。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>其实在第一篇博客里面已经简单介绍过了，不过这里还要补充一些，前面说到<strong>LifecycleBase</strong>类，它是实现了Lifecycle接口，把生命周期的状态的转变与维护、事件的触发以及监听器的添加与删除等公共的逻辑放到这个类来做，子类就可以在某个生命周期的时候专注实现自己的逻辑，看看这张类图<br><img src="https://upload-images.jianshu.io/upload_images/3110248-be5dca1e75b94dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lifecycle"><br>为了防止与接口里面的方法重名，所以<strong>LifecycleBase</strong>类往原来的生命周期方法后面加了internal，子类只要实现这些方法就可以了，直接来看看具体的代码吧，还是接着前面的init()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">     　<span class="comment">//状态检查,必须是NEW才能继续初始化</span></div><div class="line">        <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</div><div class="line">            invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 触发INITIALIZING的事件监听器</span></div><div class="line">            setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">           <span class="comment">// 抽象方法，给子类实现</span></div><div class="line">            initInternal();</div><div class="line">           <span class="comment">// 触发INITIALIZED的事件监听器</span></div><div class="line">            setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            handleSubClassException(t, <span class="string">"lifecycleBase.initFail"</span>, toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个方法逻辑比较简单，主要逻辑都写清楚了,<strong>setStateInternal()</strong>方法会拿到生命状态对应的事件，然后将事件通知到已经注册到该组件的监听器。<strong>initInternal()</strong>是抽象方法，给子类实现，其它生命周期的方法也都是类似的逻辑，其实这就是设计模式中的<strong>模板方法模式</strong>，把公共逻辑给抽象父类做了，具体的子类再去填充已经规定好的模板，这里也就是xxinternal()方法。接着回到主线，既然该方法是给子类实现的，我们看到<strong>LifecycleBase的子类StandardServer的initInternal()方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">　　......</div><div class="line">        <span class="comment">// 调用子组件Service的init()方法</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</div><div class="line">            services[i].init();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>核心功能就是初始化Service，进入Service，而Service是我们从Socket连接到Web应用真正的管家，管理着<strong>Connector和Container两大核心组件</strong>。看看Service的<strong>initInternal()</strong>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">        <span class="keyword">super</span>.initInternal();</div><div class="line">        <span class="comment">// 调用engine的init()方法</span></div><div class="line">        <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</div><div class="line">            engine.init();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 初始化线程池</span></div><div class="line">        <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</div><div class="line">            <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</div><div class="line">                ((JmxEnabled) executor).setDomain(getDomain());</div><div class="line">            &#125;</div><div class="line">            executor.init();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 初始化映射监听器 Engine-&gt;Host的映射</span></div><div class="line">        mapperListener.init();</div><div class="line"></div><div class="line">        <span class="comment">// 初始化connector</span></div><div class="line">        <span class="keyword">synchronized</span> (connectorsLock) &#123;</div><div class="line">            <span class="keyword">for</span> (Connector connector : connectors) &#123;</div><div class="line">                connector.init();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>确实是分别调用了上层容器(Engine)和连接器(Connector)的初始化方法，同时初始化了线程池和MapperListener监听器，这几个玩意一个个来，首先是<strong>Engine</strong>，调用了engine的init()方法后进入了容器的部分。容器的虽然也是从<strong>LifecycleBase</strong>继承下来的，但因为容器和其它组件相比也有自己的一部分逻辑，且容器(Container)的子组件较多，所以Tomcat用了一个<strong>ContainerBase类</strong>来继承了<strong>LifecycleBase，并实现了Container接口</strong>，简单描述一下<strong>ContainerBase</strong>做了哪些事情</p>
<ul>
<li>1.绑定父容器，获取父容器相关的信息；管理子容器，实现了容器及其监听器获取、添加、删除，以及容器状态的维护，数据销毁与事件的发送等通用方法，</li>
<li>2.维护了容器的重要组成元素<strong>Pipeline</strong>，并提供了操作Valve的通用方法</li>
<li>3.后台任务线程的管理，可以进行周期性的检查并重载相关的配置</li>
</ul>
<p>还是借助类图，才能有一个比较清晰的了解，如下<br><img src="https://upload-images.jianshu.io/upload_images/3110248-1f9172eb7f189347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lifecycle"></p>
<hr>
<p><strong>ContainerBase的initInternal()方法</strong>会实例化一个Executor线程池(默认线程数量是1)，用来启动、停止子容器。接着看到<strong>MapperListener</strong>是可以实现热部署的，当Web应用的部署信息发生变化时，就会将对应的事件通知到该监听器，然后监听器根据接收到的事件更新<strong>Mapper</strong>的信息，这里的<strong>init()方法</strong>是直接用的父类的，把当前对象在JMBean里面进行注册，与主题无关就不多说了，下面来介绍一下线程池。</p>
<h3 id="Tomcat内部的线程池"><a href="#Tomcat内部的线程池" class="headerlink" title="Tomcat内部的线程池"></a>Tomcat内部的线程池</h3><p>Tomcat的线程池是继承了jdk的线程池，并实现了Lifecycle接口，对应的类是<strong>org.apache.catalina.core.StandardThreadExecutor</strong>，它的是内部持有一个ThreadExecutor对象，真正的线程池相关的逻辑就是这个定制版的ThreadExecutor来做的，接下来看看<strong>org.apache.tomcat.util.threads.ThreadExecutor</strong>对比jdk的线程池做了哪些优化呢？首先得搞清楚jdk的线程池执行的流程是怎样的，概括来说</p>
<ul>
<li>1.任务数量还未达到coreSize个时，来一个任务就创建一个新线程</li>
<li>2.再来任务时，就把任务丢到队列里面让所有的线程去抢；如果队列满了就创建临时线程</li>
<li>3.如果总线程数达到maximumPoolSize，则执行拒绝策略<br>而Tomcat的线程池会在上述第3步(当然Tomcat也可以配置线程池的核心线程预启动)，达到最大数后不会直接执行拒绝策略，会再尝试添加任务到队列中，看看代码<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</div><div class="line">        submittedCount.incrementAndGet();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">super</span>.execute(command);</div><div class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</div><div class="line">                <span class="keyword">final</span> TaskQueue queue = (TaskQueue)<span class="keyword">super</span>.getQueue();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 继续尝试把任务放到队列中</span></div><div class="line">                    <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</div><div class="line">                        submittedCount.decrementAndGet();</div><div class="line">                        <span class="comment">// 如果添加任务失败 则执行拒绝策略</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity is full."</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</div><div class="line">                    submittedCount.decrementAndGet();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(x);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                submittedCount.decrementAndGet();</div><div class="line">                <span class="keyword">throw</span> rx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到具体的实现方式是抛出拒绝异常进行捕获后，再次尝试入队失败再手动抛出异常，这样做的原因主要是可能再次添加任务时有任务消费完了，就能继续添加任务到队列中了。这里注意还有<strong>submittedCount</strong>这么一个原子变量，用来统计已经提交到任务队列中但还未执行的任务数量，搞这么一个变量的原因肯定是和任务队列有关。首先看看jdk的队列<strong>LinkedBlockingQueue</strong>，如果指定了队列的大小还好，如果没指定默认值是Integer.MAX_VALUE，Integer的最大值，当任务数量过大，核心线程远远处理不过来的时候，还不停的添加任务到队列，并且只要没到队列的最大值就不会创建新的临时线程来处理，最后导致的结果可能就是堆内存溢出，之前任务过多时只是丢掉一些任务，现在是直接影响到应用的正常使用… Tomcat线程池的任务队列<strong>org.apache.tomcat.util.threads.TaskQueue</strong>就针对这一点进行了优化，具体实现还是继承了<strong>LinkedBlockingQueue</strong>，只要在关键点做处理就可以，直接看入队的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里的parent是ThreadExecutor</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable o)</span> </span>&#123;</div><div class="line">  <span class="comment">// 为空就直接交给父类处理</span></div><div class="line">    <span class="keyword">if</span> (parent==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</div><div class="line">    <span class="comment">//线程池的线程数量达到最大时也直接给父类处理</span></div><div class="line">    <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</div><div class="line">    <span class="comment">//如果提交但未执行的任务数量&lt;当前线程池的线程数量，说明还有空闲线程，或者马上</span></div><div class="line">  <span class="comment">// 有空闲线程了，也直接交给父类处理</span></div><div class="line">    <span class="keyword">if</span> (parent.getSubmittedCount()&lt;=(parent.getPoolSize())) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</div><div class="line">    <span class="comment">// 到这里就说明未执行的任务大于当前线程池的线程数量，如果线程数量未达到最大</span></div><div class="line">  <span class="comment">// 就直接return false 此时线程池就会创建新的线程</span></div><div class="line">    <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 默认直接丢给父类</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码的逻辑很清晰了，这样一来就能很好的<strong>解决了没达到任务队列大小时无法创建新的线程来进行处理的情况</strong>。对于jdk的线程池，现在推荐的做法都是建议进行显示的创建来指定相关的属性，特别是对于任务队列显式的指定最大数量，这样才能更好在源头上避免问题的产生，因为即使是能创建新的线程来进行处理，但任务数量增加太快时还是可能出现处理不过来的情况。再回到刚开始说的，使用<strong>StandardThreadExecutor</strong>类，主要是方便了线程池与Tomcat的组件的生命周期的统一管理，它的init()也与<strong>MapperListener</strong>一样，也直接跳过了，注意这里初始化时StandardThreadExecutor内部的线程池和任务队列并没有实例化，而是在启动时才实例化的，这里的Executor其实会通过反射的方式设置到Connector的ProtocolHandler，也就是前面的createDigester()里面配置了这个规则。接下来看看Connector的初始化方法主要做了哪些事</p>
<hr>
<h3 id="Connector的初始化"><a href="#Connector的初始化" class="headerlink" title="Connector的初始化"></a>Connector的初始化</h3><p>Connector作为管理连接、解析参数，构建请求、响应的对象，是理解Tomcat的工作流程极其重要的部分，第一篇说过Tomcat其实是一个<strong>应用服务器+Servlet容器</strong>，而Servlet容器是为了遵循JavaWeb开发的规范，在其它语言或框架可能就不会管这什么Servlet规范了，对于任何服务器框架来说，连接的管理都是最核心的部分，分析的时候前提是对Tomcat的整体有个大概了解。直接看到Connector的initInternal()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">        <span class="comment">// 初始化适配器</span></div><div class="line">        adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</div><div class="line">       <span class="comment">// 将适配器绑定到Connector内部的protocolHandler</span></div><div class="line">        protocolHandler.setAdapter(adapter);</div><div class="line"></div><div class="line">        <span class="comment">// 初始化需要解析请求体的请求类型，默认有POST 加入到HashSet 方便后续的判断</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</div><div class="line">            setParseBodyMethods(getParseBodyMethods());</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            protocolHandler.init();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</div><div class="line">                    sm.getString(<span class="string">"coyoteConnector.protocolHandlerInitializationFailed"</span>), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里的protocolHandler实际是在Connector实例化的时候在构造方法里面利用反射构建的，前面说过这个对象是对应用层协议的抽象(不熟悉的看下第一篇连接器相关的小节)，这里比较重要的是与一个<strong>Adapter实例</strong>进行了绑定，而这个实例是用来实现从连接器到容器的请求、响应对象适配工作的，接下来我们可以看到protocolHandler调用了它的init()方法，这里为了方便还是拿来前面的类图<br><img src="https://upload-images.jianshu.io/upload_images/3110248-2acfdd9e90e978f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ProtocolHandler"><br>我们的目的是搞清楚工作流程，所以以<strong>Http11NioProtocolHandler-NioEndpoint</strong>这条线来摸清楚流程，继续跟进去发现最初的init()方法是在<strong>AbstractHttp11Protocol</strong>这个抽象父类，这个类的构造方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractHttp11Protocol</span><span class="params">(AbstractEndpoint&lt;S,?&gt; endpoint)</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>(endpoint);</div><div class="line">       <span class="comment">// 设置连接超时</span></div><div class="line">       setConnectionTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);</div><div class="line">      <span class="comment">// 实例化连接处理器</span></div><div class="line">       ConnectionHandler&lt;S&gt; cHandler = <span class="keyword">new</span> ConnectionHandler&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">       <span class="comment">// 分别与ProtocolHandler的实现类 以及 Endpoint进行绑定</span></div><div class="line">       setHandler(cHandler);</div><div class="line">       getEndpoint().setHandler(cHandler);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这里面会调用父类的构造方法，把<strong>Endpoint</strong>传进去，这是我们处理连接和读写事件干事的地方，稍后在详细描述，看到接下来几行代码会实例化ConnectorHandler，并且与当前Endpoint进行绑定，这个ConnectHandler主要的职责是用来管理SocketProcessor，后面在源码中会看到的。回到主线，<strong>AbstractHttp11Protocol</strong>的init()方法首先会进行协议升级相关的配置，这个我们不用管，接着会调用父类<strong>AbstractProtocol</strong>的init()方法，看看它的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   ...</div><div class="line">    String endpointName = getName();</div><div class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</div><div class="line">    endpoint.setDomain(domain);</div><div class="line">   <span class="comment">// 调用endpoint的init方法</span></div><div class="line">    endpoint.init();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里逻辑也比较简单，所以我们继续跟进到<strong>NioEndPoint</strong>的init()方法，这里还是把类图拿过来<br><img src="https://upload-images.jianshu.io/upload_images/3110248-28ba9586ba4a065d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EndPoint"><br>同样它的init()方法也是在最终的抽象父类<strong>AbstractEndpoint</strong>，主要有这么一段逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (bindOnInit) &#123;</div><div class="line">          bindWithCleanup();</div><div class="line">          bindState = BindState.BOUND_ON_INIT;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>bindOnInit</strong>指在是否初始化时进行端口的绑定，默认是true，它会调用<strong>bindWithCleanup()</strong>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindWithCleanup</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            bind();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="comment">// Ensure open sockets etc. are cleaned up if something goes</span></div><div class="line">            <span class="comment">// wrong during bind</span></div><div class="line">            ExceptionUtils.handleThrowable(t);</div><div class="line">            unbind();</div><div class="line">            <span class="keyword">throw</span> t;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个bind()也是一个抽象模板方法，目的是给子类实现的，所以我们的init()方法最终到了<strong>NioEndpoint</strong>的bind()方法，上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//初始化服务器端Socket</span></div><div class="line">        initServerSocket();</div><div class="line">        <span class="comment">//初始化acceptor线程数量</span></div><div class="line">        <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</div><div class="line">            acceptorThreadCount = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">       <span class="comment">// 初始化poller线程数量</span></div><div class="line">        <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">            pollerThreadCount = <span class="number">1</span>;</div><div class="line">        &#125; </div><div class="line">       <span class="comment">// 设置未停止的轮训器数量</span></div><div class="line">        setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</div><div class="line">        <span class="comment">// 如果需要ssl就进行初始化的配置</span></div><div class="line">        initialiseSsl();</div><div class="line">        <span class="comment">// 初始化selectorPool</span></div><div class="line">        selectorPool.open();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先看到initServerSocket()方法会先初始化ServerSocket，也就是如下几行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">serverSock = ServerSocketChannel.open();</div><div class="line">socketProperties.setProperties(serverSock.socket());</div><div class="line">InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress(getAddress(), getPortWithOffset()); serverSock.socket().bind(addr,getAcceptCount());</div><div class="line">serverSock.configureBlocking(<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<p>需要清楚的是对于ServerSocketChannel，Tomcat直接使用的阻塞的方式来监听连接，也无需注册到Selector，确实意义不大，反正建立连接后就不归它管了。接着会初始化<strong>Acceptor和Poller</strong>的线程数量，在第一篇里面介绍过，<strong>Acceptor是用来接收新的连接的线程，建立连接后就把连接通道Channel交给众多Poller中的一个；Poller是用来检测已经建立好的连接的IO事件，对应的也就是jdk的selector(多路复用器)</strong>，具体的代码还在后面，继续看到<strong>bind()</strong>方法的最后一行，会调用selectorPool的open()方法，那么这个selectorPool又是个啥东西呢？<strong>selectorPool是org.apache.tomcat.util.net.NioSelectorPool的一个实例对象，它的职责其实是作为一个辅助Selector</strong>，而前面说到的Poller一般称被称为主Selector，后续在进行具体分析。</p>
<h2 id="正式启动"><a href="#正式启动" class="headerlink" title="正式启动"></a>正式启动</h2><p>前面从讲了从init()方法开始主要做的事情，接下来就看看Catalina的start()方法，上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        ......</div><div class="line">        <span class="comment">// Start the new server   </span></div><div class="line">      getServer().start();</div><div class="line">        <span class="comment">// Register shutdown hook</span></div><div class="line">     <span class="keyword">if</span> (useShutdownHook) &#123;</div><div class="line">            <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</div><div class="line">                shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</div><div class="line">            &#125;</div><div class="line">            Runtime.getRuntime().addShutdownHook(shutdownHook);</div><div class="line">     &#125;</div><div class="line">      <span class="keyword">if</span> (await) &#123;</div><div class="line">            await();</div><div class="line">            stop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>代码精简后，这里首先调用了getServer().start()，这里先放一放，接着看看后面的代码，首先判断是否useshutdownHook，默认为true。接着往Runtime里面添加了了一个CatalinaShutdownHook，其实也就是一个Thread对象实例，它的里面就是停止和进行资源回收的逻辑，这是挺实用的一个东西，也就是为了防止应用异常停止的时候资源得不到正确回收，以前写Java的gui程序的时候就很容易出现明明调用了System.exit()，但进程还是运行着，注册到Runtime，也就是当前应用的运行环境后，应用停止时会自动调用它里面的逻辑，这一点是由JVM来进行保证的，JVM的进程在完全退出前会自动去执行所有注册了的ShutdownHook的逻辑；此外，后面await()方法还通过启动一个Socket服务端，来监听SHUTDOWN消息，验证通过后进入stop流程。接着直接跳到StandardServer的start()方法，前面初始化时说过，这些生命周期相关的方法基本的逻辑都交给父类去处理了,子类直接进行xxInternal()方法进行自己的逻辑，所以我们直接看到startInternal()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">        <span class="comment">// 通知已注册的监听器</span></div><div class="line">        fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="keyword">null</span>);</div><div class="line">        setState(LifecycleState.STARTING);</div><div class="line">        <span class="comment">// 启动全局命名服务</span></div><div class="line">        globalNamingResources.start();</div><div class="line"></div><div class="line">        <span class="comment">// 启动Service</span></div><div class="line">        <span class="keyword">synchronized</span> (servicesLock) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</div><div class="line">                services[i].start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>逻辑很简单，首先通知已注册的监听器，包括正常对生命周期进行监控的，以及需要加载某些配置的。接着会遍历所有已经添加了的Service，并调用它们的start()方法，这里也直接看到StandardService的startInternal()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">    <span class="comment">// 通知监听器当前正在启动</span></div><div class="line">    setState(LifecycleState.STARTING);</div><div class="line">   </div><div class="line">    <span class="comment">// 启动Service层级下的首个容器Engine</span></div><div class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (engine) &#123;</div><div class="line">            engine.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">// 启动Executor，此时线程池与任务队列才实例化</span></div><div class="line">    <span class="keyword">synchronized</span> (executors) &#123;</div><div class="line">        <span class="keyword">for</span> (Executor executor: executors) &#123;</div><div class="line">            executor.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">// 启动Mapper监听器 </span></div><div class="line">    mapperListener.start();</div><div class="line"></div><div class="line">    <span class="comment">// 启动所有的连接器</span></div><div class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</div><div class="line">        <span class="keyword">for</span> (Connector connector: connectors) &#123;</div><div class="line">            <span class="comment">// If it has already failed, don't try and start it</span></div><div class="line">            <span class="keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;</div><div class="line">                connector.start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="容器的启动"><a href="#容器的启动" class="headerlink" title="容器的启动"></a>容器的启动</h3><p>这里首先会启动Service的首个子容器Engine，我们继续跟进StandardEngine的startInternal()方法，不过它除了打印日志以外没做任何事，是直接调用了父类ContainerBase的startInternal()方法，直接看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">        <span class="comment">// 找到所有的子容器 并进行启动</span></div><div class="line">        Container children[] = findChildren();</div><div class="line">        List&lt;Future&lt;Void&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</div><div class="line">            results.add(startStopExecutor.submit(<span class="keyword">new</span> StartChild(children[i])));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Future&lt;Void&gt; result : results) &#123;</div><div class="line">                result.get();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 调用管道(Pipeline)中所有阀门(Valve)的start()方法</span></div><div class="line">        <span class="keyword">if</span> (pipeline <span class="keyword">instanceof</span> Lifecycle) &#123;</div><div class="line">            ((Lifecycle) pipeline).start();</div><div class="line">        &#125;</div><div class="line">        setState(LifecycleState.STARTING);</div><div class="line">        <span class="comment">//启动周期性任务执行的线程</span></div><div class="line">        threadStart();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这部分是所有容器的公共逻辑，代码也比较简单，首先<strong>找到所有的子容器并进行启动</strong>，只是这里使用的是Future来提交任务的，与Runnable相比，没多大区别，Future是方便设置任务执行的结果的，然后通过get()来获取，不过这里使用Future也没看到有什么作用，返回值也是Void，估计是为了后期的扩展。看到下面的，接着会调用管道的start()方法，Tomcat的标准实现类是StandardPipeline，它的start()方法会去遍历Pipeline内所有的Valve，并调用它们start()方法，接着看到最后一行threadStart()，它会启动一个线程执行周期性的任务，对应的Runnable就是ContainerBackgroundProcessor，看看它的run方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (!threadDone) &#123;</div><div class="line">                   <span class="keyword">try</span> &#123;</div><div class="line">                       Thread.sleep(backgroundProcessorDelay * <span class="number">1000L</span>);</div><div class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                       <span class="comment">// Ignore</span></div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">if</span> (!threadDone) &#123;</div><div class="line">                       processChildren(ContainerBase.<span class="keyword">this</span>);</div><div class="line">                   &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>只要线程没结束，就不停的执行周期性的任务，接着会调用processChildren()，看看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processChildren</span><span class="params">(Container container)</span> </span>&#123;</div><div class="line">                <span class="comment">// 调用容器的任务处理方法</span></div><div class="line">                container.backgroundProcess();</div><div class="line">                Container[] children = container.findChildren();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (children[i].getBackgroundProcessorDelay() &lt;= <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// 递归调用所以子容器</span></div><div class="line">                        processChildren(children[i]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些主要就是调用了容器的backgroundProcess()，并递归的所有对所有子容器进行同样的调用，所以可以知道了只要我们在容器里面重写backgroundProcess()方法，就可以做一些周期性执行的任务，并且，例如资源的热加载，session对象有效期的管理等。</p>
<h3 id="线程池与Mapper的启动"><a href="#线程池与Mapper的启动" class="headerlink" title="线程池与Mapper的启动"></a>线程池与Mapper的启动</h3><p>还是按照StandardService里面代码的顺序，这里线程池对应的管理者是StandardExecutor，它的启动方法只是把内部真正的ThreadExectuor和TaskQueue实例化，接着来看看MapperListener的startInternal()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line">        <span class="comment">// 通知监听器状态改变</span></div><div class="line">        setState(LifecycleState.STARTING);  </div><div class="line">        <span class="comment">// Engine为空直接返回</span></div><div class="line">        Engine engine = service.getContainer();</div><div class="line">        <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找到默认的Host</span></div><div class="line">        findDefaultHost();</div><div class="line">        <span class="comment">// 递归的给所有的子容器添加监听器 </span></div><div class="line">        addListeners(engine);</div><div class="line">       <span class="comment">// 处理子容器，绑定提前配置好的映射</span></div><div class="line">        Container[] conHosts = engine.findChildren();</div><div class="line">        <span class="keyword">for</span> (Container conHost : conHosts) &#123;</div><div class="line">            Host host = (Host) conHost;</div><div class="line">            <span class="keyword">if</span> (!LifecycleState.NEW.equals(host.getState())) &#123;</div><div class="line">                <span class="comment">// Registering the host will register the context and wrappers</span></div><div class="line">                registerHost(host);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Mapper是比较重要的一个组件，看看上面的代码，findDefaultHost()首先配置默认的主机名，也就是，默认情况下也就是localhost，还是看看图<br><img src="https://upload-images.jianshu.io/upload_images/3110248-8177e7af61f0139b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mapper"><br>这里就很清楚容器的各层组件表示的具体对象了，实际上这是对于常规的Servlet项目而言，对于平时部署Spring的项目而言，Context和Wrapper其实都是/，把请求和响应对象包装好后在DispatcherServlet的内部再对uri处理，最后会找到Controller里面的映射路径对应的方法。回到上面的代码，接着addListeners()方法会递归的给每个子容器都添加了MapperListener监听器，所以可以知道子容器的Mapper都是共享的同一个，继续接下来的代码就是配置默认的每层组件到子容器的映射。接下来就看连接器的启动了</p>
<h3 id="Connector的启动"><a href="#Connector的启动" class="headerlink" title="Connector的启动"></a>Connector的启动</h3><p>Connector的start()方法，里面也是调用了ProtocolHandler的start()方法，所以直接看到它的子类AbstractProtocolHandler的启动方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 启动Endpoint</span></div><div class="line">        endpoint.start();</div><div class="line"></div><div class="line">        <span class="comment">// 开启异步超时线程</span></div><div class="line">        asyncTimeout = <span class="keyword">new</span> AsyncTimeout();</div><div class="line">        Thread timeoutThread = <span class="keyword">new</span> Thread(asyncTimeout, getNameInternal() + <span class="string">"-AsyncTimeout"</span>);</div><div class="line">        <span class="keyword">int</span> priority = endpoint.getThreadPriority();</div><div class="line">        <span class="keyword">if</span> (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY) &#123;</div><div class="line">            priority = Thread.NORM_PRIORITY;</div><div class="line">        &#125;</div><div class="line">        timeoutThread.setPriority(priority);</div><div class="line">        timeoutThread.setDaemon(<span class="keyword">true</span>);</div><div class="line">        timeoutThread.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>它的启动方法主要是做两件事情，调用Endpoint的start()，稍后进行描述；另外一件事情是开启了检测异步Servlet超时的线程，简单说一下，跟异步Servlet相关的processor会放到一个waitingProcessors集合中，因为使用异步的时候，任务的具体处理交给了Tomcat外部的线程，但连接是由Tomcat进行的管理，所以必须保证它的读写有一个时间限制，不然里连接就可能会一直占用着，由于篇幅有限，这里就不讨论异步Servlet有关的了。</p>
<h3 id="EndPoint"><a href="#EndPoint" class="headerlink" title="EndPoint"></a>EndPoint</h3><p>回到Endpoint，AbstarctEndpoint的start()只会判断一下没绑定就进行下bind()的逻辑，接着就只有一个给子类的startInternal()方法，所以可以直接看到NioEndPoint的该方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!running) &#123;</div><div class="line">            running = <span class="keyword">true</span>;</div><div class="line">            paused = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">// 实例化处理器对象缓存栈</span></div><div class="line">            processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</div><div class="line">                    socketProperties.getProcessorCache());</div><div class="line">           <span class="comment">// 实例化事件对象缓存栈</span></div><div class="line">            eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</div><div class="line">                            socketProperties.getEventCache());</div><div class="line">           <span class="comment">// 实例化NioChannel对象缓存栈</span></div><div class="line">            nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</div><div class="line">                    socketProperties.getBufferPool());</div><div class="line"></div><div class="line">            <span class="comment">// 线程池为空则创建新的</span></div><div class="line">            <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</div><div class="line">                createExecutor();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 初始化连接限制计数器</span></div><div class="line">            initializeConnectionLatch();</div><div class="line"></div><div class="line">            <span class="comment">// 实例化并启动多个Poller线程</span></div><div class="line">            pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</div><div class="line">                pollers[i] = <span class="keyword">new</span> Poller();</div><div class="line">                Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</div><div class="line">                pollerThread.setPriority(threadPriority);</div><div class="line">                pollerThread.setDaemon(<span class="keyword">true</span>);</div><div class="line">                pollerThread.start();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 实例化并启动多个Acceptor线程</span></div><div class="line">            startAcceptorThreads();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>到这里就要先好好介绍一下Endpoint里面最重要的几个对象了</p>
<ul>
<li>Acceptor: 用来接收ServerSocketChannel连接请求的对象，会不停的轮询是否有新的连接加入，也就是调用serverSocketAccept()方法，然后把连接返回的SocketChannel使用NioChannel包装，再选择一个Poller进行注册，注册时会再把NioChannel使用NioSocketWrapper(NioEndPoint中SocketWrapperBase的具体实现类)进行包装，并生成一个新的事件PollerEvent，对应的也就是jdk的SelectionKey里面的事件类型，，然后加入到Poller的事件队列中。</li>
<li><p>Poller: 内部持有一个事件队列和多路复用器(Selector)，内部会有一个while(true)循环不停的从事件队列中取出一个事件，把事件注册到持有的Selector，并且会把NioSocketWrapper绑定到对SelectionKey，然后查询是否有事件就绪，接着会把就绪好的事件去丢到SocketProcessor里面放到线程池去处理，SocketProcessor会取出当前的EndPoint中的ConnectionHandler，也就是前面讲的在AbstractEndpoint的构造方法里面实例化的，接着它会把NioSocketWrapper丢到Http11Processor里面进行处理。<br><img src="https://upload-images.jianshu.io/upload_images/3110248-9d45a004095f4b44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>Processor: 可以看看上面的类图，这里我们关注点是Http11Processor。这里面会实例化org.apache.coyote.Request和org.apache.coyote.Response对象，并且持有Http11InputBuffer和Http11OutputBuffer两个对象，这两个对象会真正的从Socket通道读取到具体的数据，当然它的读取还是通过内部持有的NioSocketWrapper，并对请求进行初步的处理，也就是解析请求行和请求头，而请求体是在业务层进行调用时再进行读取和解析。最后会把请求交给Adapter进行处理，Adapter会把coyote包下的Request和Response包装到org.apache.catalina.connector包下的Request和Response，而这两个对象是继承了HttpServletRequest和HttpServletResponse的，再接着请求就会到容器了。</p>
</li>
</ul>
<hr>
<p>回到上面的代码首先会初始化化3个同步栈，processorCache是用来存储SocketProcessor，evenCache是用来存储Poller里面的Event，nioChannelCache是用来存储NioChanel，它们都是SynchronizedStack的实例，这个对象是Tomcat用来做对象的缓存池的，也就是说把用完的对象丢到缓存池，下次再需要这些对象时就可以重用，用的时候再进行重置；缓冲池拿不到了，再创建新的，用完还是丢回缓存池，直到达到上限。这样做的好处是减少了常用对象的初始、实例化的开销以及减少垃圾收集器对堆内存进行回收的频率，但也有一点是会涉及到多个线程的抢占，有锁的竞争与释放的开销。</p>
<p>接着下面的代码 initializeConnectionLatch()会初始化一个限制连接数量的LimitLatch，Acceptor必须得先拿到锁才能去监听新连接的到来，否则就一直等待，使用这种方式从上层限制了并发连接的数量，保证了正常业务处理的进行，它的实现也是基于jdk中的AQS。接下来的代码就是实例化并启动了Poller和Acceptor的线程，到此请求就能正常的到来了。</p>
<h2 id="一次请求的过程"><a href="#一次请求的过程" class="headerlink" title="一次请求的过程"></a>一次请求的过程</h2><p>前面写了那么多，在主线已经把初始化和启动完成了，现在能正常接收并处理请求了，就下来就看看请求是怎么走的，其实界面介绍Endpoint几个组件的时候已经把主要的流程过了一遍，不过还是要来看实际的代码，心里才更加踏实。</p>
<h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h3><p>要看请求，自然是从连接的到来开始，所以直接看到<br>Acceptor的run方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Loop until we receive a shutdown command</span></div><div class="line">        <span class="keyword">while</span> (endpoint.isRunning()) &#123;</div><div class="line">            state = AcceptorState.RUNNING;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 连接计数器 达到最大连接则等待</span></div><div class="line">                endpoint.countUpOrAwaitConnection();</div><div class="line">                U socket = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 从服务器监听新到来的连接</span></div><div class="line">                    socket = endpoint.serverSocketAccept();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</div><div class="line">                    <span class="comment">// We didn't get a socket</span></div><div class="line">                    endpoint.countDownConnection();</div><div class="line">                    ......</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) &#123;       </div><div class="line">                      <span class="comment">// 配置SocketChannel</span></div><div class="line">                    <span class="keyword">if</span> (!endpoint.setSocketOptions(socket)) &#123;</div><div class="line">                        endpoint.closeSocket(socket);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    endpoint.destroySocket(socket);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">               ......</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        state = AcceptorState.ENDED;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>代码进行了精简，可以看到Acceptor会在一个while循环里面，首先看连接数量是否达到上线，然后去监听服务器端的连接请求，连接到来后会获取到一个SocketChannel对象，接着会调用setSocketOptions()方法进行参数的配置，接着会进行下一轮循环，跟进去看看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</div><div class="line">        <span class="comment">// Process the connection</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 设置非阻塞</span></div><div class="line">            socket.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            Socket sock = socket.socket();</div><div class="line">            <span class="comment">// 拿到SocketChannel内部的socket进行相关的参数配置</span></div><div class="line">            socketProperties.setProperties(sock);</div><div class="line">            <span class="comment">// 从NioChannel缓冲池拿一个对象实例出来</span></div><div class="line">            NioChannel channel = nioChannels.pop();</div><div class="line">           <span class="comment">// 为空则创建新的</span></div><div class="line">            <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// 实例化内部NioChannel内部的读写缓冲区处理器</span></div><div class="line">                SocketBufferHandler bufhandler = <span class="keyword">new</span> SocketBufferHandler(</div><div class="line">                        socketProperties.getAppReadBufSize(),</div><div class="line">                        socketProperties.getAppWriteBufSize(),</div><div class="line">                        socketProperties.getDirectBuffer());</div><div class="line">                <span class="comment">// 判断是否开启ssl</span></div><div class="line">                <span class="keyword">if</span> (isSSLEnabled()) &#123;</div><div class="line">                    channel = <span class="keyword">new</span> SecureNioChannel(socket, bufhandler, selectorPool, <span class="keyword">this</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不为空就把SocketChannel设置进去</span></div><div class="line">                channel.setIOChannel(socket);</div><div class="line">                <span class="comment">// 为防止资源污染 需要进行重置 清空内部的缓冲区</span></div><div class="line">                channel.reset();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 注册到众多Poller中的一个</span></div><div class="line">            getPoller0().register(channel);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            ......</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，首先会先设置SocketChannel为非阻塞，然后拿到它内部的Socket进行基础的参数配置，要清楚一点，SocketChannel只是Java Nio出来后为了实现非阻塞弄出来的一套Api，内部实现还是用的Socket。接着会尝试从缓冲区nioChannels从拿到可以复用的实例对象，没有则创建新的，注意创建的时候需要一个实例对象SocketBufferHandler，因为Nio进行读写数据都是通过Bytebuffer，所以这是为了NioChannel内部方便进行Bytebuffer的分配、扩容、管理使用的。最后看到会把NioChannel注册到Poller里面，继续跟进行getPoller0().register()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> NioChannel socket)</span> </span>&#123;</div><div class="line">           <span class="comment">// 把NioChannel与当前Poller进行绑定 </span></div><div class="line">           socket.setPoller(<span class="keyword">this</span>);</div><div class="line">           <span class="comment">// 实例化一个NioSocketWrapper 把NioChannel再进行一层包装</span></div><div class="line">            NioSocketWrapper ka = <span class="keyword">new</span> NioSocketWrapper(socket, NioEndpoint.<span class="keyword">this</span>);</div><div class="line">           <span class="comment">// 与NioChannel进行绑定</span></div><div class="line">            socket.setSocketWrapper(ka);</div><div class="line">            <span class="comment">// 设置一些参数...</span></div><div class="line">            ka.setPoller(<span class="keyword">this</span>);</div><div class="line">            ka.setReadTimeout(getConnectionTimeout());</div><div class="line">            ka.setWriteTimeout(getConnectionTimeout());</div><div class="line">            ka.setKeepAliveLeft(NioEndpoint.<span class="keyword">this</span>.getMaxKeepAliveRequests());</div><div class="line">            ka.setSecure(isSSLEnabled());</div><div class="line">            <span class="comment">// 从事件队列缓冲区拿到一个事件</span></div><div class="line">            PollerEvent r = eventCache.pop();</div><div class="line">            <span class="comment">// 表明对读事件感兴趣</span></div><div class="line">            ka.interestOps(SelectionKey.OP_READ);<span class="comment">//this is what OP_REGISTER turns into.</span></div><div class="line">            <span class="comment">// 给新来的通道事件类型设置为OP_REGISTER</span></div><div class="line">            <span class="keyword">if</span> ( r==<span class="keyword">null</span>) r = <span class="keyword">new</span> PollerEvent(socket,ka,OP_REGISTER);</div><div class="line">            <span class="keyword">else</span> r.reset(socket,ka,OP_REGISTER);</div><div class="line">            <span class="comment">// 添加到事件队列  </span></div><div class="line">            addEvent(r);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>到这里NioChannel又被加了一层包装NioSocketWrapper，接着会从事件队列的缓冲区eventCache里面拿到一个事件，并设置事件类型为OP_REGISTER，接着把事件添加到了Poller内部的事件队列。</p>
<h3 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h3><p>接着直接看到Poller线程的run方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// Loop until destroy() is called</span></div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">boolean</span> hasEvents = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                     <span class="comment">// 如果没关闭 首先查看是否有事件</span></div><div class="line">                    <span class="keyword">if</span> (!close) &#123;</div><div class="line">                        <span class="comment">// 看到事件队列中是否还有事件</span></div><div class="line">                        hasEvents = events();</div><div class="line">                        <span class="comment">// wakeupCounter原子变量是在添加事件时进行计数的</span></div><div class="line">                       <span class="comment">// &gt; 0则表明已经有事件注册到SocketChannel了</span></div><div class="line">                        <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</div><div class="line">                            <span class="comment">// 立刻唤醒selector</span></div><div class="line">                            keyCount = selector.selectNow();</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                           <span class="comment">// 到这里表明没有事件，直接使用selector.select()进行阻塞直到超时</span></div><div class="line">                            keyCount = selector.select(selectorTimeout);</div><div class="line">                        &#125;</div><div class="line">                       <span class="comment">// 更新wakeupCounter为0</span></div><div class="line">                        wakeupCounter.set(<span class="number">0</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果Poller已经关闭了 直接调用timeout()方法，取消所有已经注册的事件</span></div><div class="line">                   <span class="comment">// 并关闭已经连接的通道</span></div><div class="line">                    <span class="keyword">if</span> (close) &#123;</div><div class="line">                        events();</div><div class="line">                        timeout(<span class="number">0</span>, <span class="keyword">false</span>);</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            selector.close();</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">                            log.error(sm.getString(<span class="string">"endpoint.nio.selectorCloseFail"</span>), ioe);</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                    ExceptionUtils.handleThrowable(x);</div><div class="line">                    log.error(<span class="string">""</span>,x);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 上次唤醒后没有事件 再调用events()看看队列是否有事件了 </span></div><div class="line">                <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</div><div class="line">                <span class="comment">// 拿到已经有事件就绪的SelectionKey</span></div><div class="line">                Iterator&lt;SelectionKey&gt; iterator =</div><div class="line">                    keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</div><div class="line">                    SelectionKey sk = iterator.next();</div><div class="line">                   <span class="comment">// 拿到SocketChannel的事件注册到selector时，返回的SelectionKey绑定的对象</span></div><div class="line">                    NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</div><div class="line">                    <span class="comment">// Attachment may be null if another thread has called</span></div><div class="line">                    <span class="comment">// cancelledKey()</span></div><div class="line">                    <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</div><div class="line">                        iterator.remove();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        iterator.remove();</div><div class="line">                       <span class="comment">// 绑定的NioSocketWrapper不为空则调用processKey()方法进行事件的处理</span></div><div class="line">                        processKey(sk, attachment);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//处理超时</span></div><div class="line">                timeout(keyCount,hasEvents);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 对已经停止运行的Poller进行计数</span></div><div class="line">            getStopLatch().countDown();</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>主要逻辑都已经写清楚了，同样Poller也是在一个while(true)循环进行的，我们前面的时候说过，调用getPoller0().register()只是生成新的事件放到事件队列里面，并还没有注册到selector，粗略一看，Poller的run方法里面有一个events()方法可能是注册的地方，跟进去看看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">events</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">            PollerEvent pe = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != <span class="keyword">null</span>; i++ ) &#123;</div><div class="line">                result = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    pe.run();</div><div class="line">                    <span class="comment">// 到这里之前的PollerEvent对象就没用了 进行重置</span></div><div class="line">                    pe.reset();</div><div class="line">                    <span class="comment">// 然后把事件重新丢到缓存队列eventsCache中</span></div><div class="line">                    <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</div><div class="line">                        eventCache.push(pe);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> ( Throwable x ) &#123;</div><div class="line">                    log.error(<span class="string">""</span>,x);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>发现这个方法就是从事件队列取出事件，然后调用了事件的run方法，接着跟进去<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 如果事件类型是OP_REGISTER则直接注册OP_READ事件</span></div><div class="line">            <span class="keyword">if</span> (interestOps == OP_REGISTER) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    socket.getIOChannel().register(</div><div class="line">                            socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception x) &#123;</div><div class="line">                    log.error(sm.getString(<span class="string">"endpoint.nio.registerFail"</span>), x);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 <span class="comment">// 查询该SocketChannel是否已经在当前Poller的selector里面进行了注册</span></div><div class="line">                <span class="keyword">final</span> SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 没查询到结果直接关闭连接</span></div><div class="line">                    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">                        socket.socketWrapper.getEndpoint().countDownConnection();</div><div class="line">                        ((NioSocketWrapper) socket.socketWrapper).closed = <span class="keyword">true</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// 查询到结果则取出key绑定的NioSocketWrapper</span></div><div class="line">                        <span class="keyword">final</span> NioSocketWrapper socketWrapper = (NioSocketWrapper) key.attachment();</div><div class="line">                        <span class="comment">// 不为空则重新注册感兴趣的事件</span></div><div class="line">                        <span class="keyword">if</span> (socketWrapper != <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="comment">//we are registering the key to start with, reset the fairness counter.</span></div><div class="line">                            <span class="keyword">int</span> ops = key.interestOps() | interestOps;</div><div class="line">                            socketWrapper.interestOps(ops);</div><div class="line">                            key.interestOps(ops);</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="comment">// 为空则取消已经注册事件到Selector的Socketchannel</span></div><div class="line">                            socket.getPoller().cancelledKey(key);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</div><div class="line">                    <span class="comment">// 捕获到异常直接取消注册</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        socket.getPoller().cancelledKey(key);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到代码，如果感兴趣的事件类型是OP_REGISTER的话(而新连接到来，创建PollerEvent对象时传入的就是OP_REGISTER)，直接把SocketChannel注册到Selector，注册了该Channel的读事件，并且把NioSocketWrapper绑定到了注册成功后返回的SelectionKey的attachment中，这样有事件就绪时直接把该对象拿出来，进行后续的读操作，后续的逻辑都有注释就不多说了。<br>现在看到了最终注册事件的地方，接着回溯到Poller的run方法，可以看到使用selector.select()，等待已连接的通道是否有事件就绪了，然后就是nio标准的写法，再贴一下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> // 拿到已经有事件就绪的SelectionKey</div><div class="line">Iterator&lt;SelectionKey&gt; iterator =  keyCount &gt; 0 ? selector.selectedKeys().iterator() : null;</div><div class="line">while (iterator != null &amp;&amp; iterator.hasNext()) &#123;</div><div class="line">          SelectionKey sk = iterator.next();</div><div class="line">          // 拿到SocketChannel的事件注册到selector时，返回的SelectionKey绑定的对象</div><div class="line">          NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</div><div class="line">          // Attachment may be null if another thread has called</div><div class="line">          // cancelledKey()</div><div class="line">          if (attachment == null) &#123;</div><div class="line">                   iterator.remove();</div><div class="line">          &#125; else &#123;</div><div class="line">                   iterator.remove();</div><div class="line">                   // 绑定的NioSocketWrapper不为空则调用processKey()方法进行事件的处理</div><div class="line">                  processKey(sk, attachment);</div><div class="line">         &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到有事件就绪的通道就会调用processKey()方法，这个方法会对已就绪事件的类型进行判断，最后调用到AbstarcEndpoint里面的processSocket()，直接上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></div><div class="line"><span class="function"><span class="params">            SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (socketWrapper == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 从processorCache缓存区中拿到SocketProcessor</span></div><div class="line">            SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</div><div class="line">            <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</div><div class="line">                sc = createSocketProcessor(socketWrapper, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sc.reset(socketWrapper, event);</div><div class="line">            &#125;</div><div class="line">           <span class="comment">// 把该任务丢到线程池来执行</span></div><div class="line">            Executor executor = getExecutor();</div><div class="line">            <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</div><div class="line">                executor.execute(sc);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sc.run();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</div><div class="line">            ......</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里就会看到从processorCache里面拿到SocketProcessor对象，并且给它赋值NioSocketWrapper和event后会放到线程池中去处理，这个SocketProcessor主要做了这么一件事<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">state = getHandler().process(socketWrapper, event);</div></pre></td></tr></table></figure></p>
<p>getHandler()也就是开始提到的ConnectionHandler，它的process()代码较多，这里就不贴出来了，总的来说主要就是创建Http11Processor的实例，并且把它与NioChannel建立映射，如果下次还有这个连接的请求到来，会从map中复用同一个Http11Processor。接着会调用processor.process()方法，最终会调用到Http11Processor的service()。</p>
<h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><p>虽然看代码实际点，但这几个地方细节太多，而且很多与主线无关的逻辑，就直接总结一下Http11Processor主要做了以下几件事</p>
<ul>
<li>Http11Processor内部持有Http11InputBuffer和Http11OutputBuffer两个类，这两个类会分别绑定到org.apache.coyote.Request和org.apache.coyote.Response对象，这两个类又会绑定了NioSocketWrapper，所有的读写还是通过NioSocketWrapper来进行的。接着在service()方法会通过Http11InputBuffer读取连接通道里面的数据到缓冲区，然后进行预处理，解析请求行和请求头。</li>
<li>把解析的结果填充到request和response实例对象，接着会调用getAdapter().service()方法，传入request和response对象，这个Adapter对应的实例是CoyoteAdapter，用来将request和response适配到Servlet中的HttpServletRequest和HttpServletResponse接口，Tomcat对应的实现类是org.apache.catalina.connector.Request和org.apache.catalina.connector.Response。</li>
</ul>
<p>最后还是借一张图片来看看整个过程<br><img src="http://upload-images.jianshu.io/upload_images/3110248-8f324232291f4d0c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt=""></p>
<h3 id="CoyoteAdapter"><a href="#CoyoteAdapter" class="headerlink" title="CoyoteAdapter"></a>CoyoteAdapter</h3><p>Adapter的主要职责是为了解耦，因为完全可以在Connector(连接器)里面直接调用方法进入Contaienr(容器)的，但由于这两者之间并无太多关联，对与Connector来说，应用层可以有多种协议，IO模型也可以有多种，但这些东西Container并不关心，Container只需要上层包装好的满足Servlet规范的接口实现类即可，所以用了Adapter来连接这两个模块，并且Adapter里面还可以做一些公用的全局管理的逻辑，Adapter的实现类CoyoteAdapter会对request和response进行进一步处理，如请求uri是否可以进一步处理(也就是使用url拼接的方式进行传参)，解析cookie中的sessionId和ssl的session，并且添加了对异步Servlet的支持以及完成后数据缓冲区的刷新。上面说了中转，所以实现类里有这么一句逻辑来进入到容器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(</div><div class="line">                        request, response);</div></pre></td></tr></table></figure></p>
<p>也就是调用Service中的第一个容器Engine内部的Pipeline的第一个Valve，把reques和response对象传进去，接着每个容器的的Pipeline中的基础Valve，也就是StandardxxxValve，都会调用类似的逻辑进入到下一层容器，如果子容器有多个就会使用之前设置好的Mapper进行路由，直到到达Wrapper后，就会通过反射来实例化Servlet对象，过滤器也就是在这一层做的，最终会调用到Servlet的service()方法，篇幅有限，容器这里就不多费口舌了。最后还要了解清楚Endpoint初始化时提到的NioSelectorPool对象，才算是真正清楚了数据读写的流程。</p>
<h3 id="NioSelectorPool"><a href="#NioSelectorPool" class="headerlink" title="NioSelectorPool"></a>NioSelectorPool</h3><p>前面说过Poller被称为主selector，而NioSelectorPool被称为辅助selector，所以最后一个知识点就是来探索一下NioSelectorPool究竟做了哪些工作。首先要先搞清楚一点，我们前面所说的最终数据的读写都是使用的NioSocketWrapper，是因为NioSocketWrapper内部持有NioChannel，而NioChannel又是对SocketChannel的包装，所以最终的处理很自然的想到直接在这个类里面调用SocketChannel的read()或write()就完事了，但实际情况可能没想象中的那么好。想想这么一种情况，前面说过Poller内部的selector在检测到有读、写事件就绪的时候，最终会把对应的连接通道读写的处理放到线程池中，所以只要读写没完成，当前的连接通道会一直占用着线程池中的工作线程。如果数据的读写能正常进行还好，但如果由于网络等原因连接通道暂时不能读取数据，要么我们等待读写超时直接放弃掉读写数据的连接通道，但如果这个连接通道马上可以进行数据的读写处理了，又要重新建立连接，进行一系列的调度；要么等到超时的时候，把连接通道重新注册读、写事件到主selector(Poller)，但关键是如果连接还是不能正常使用的话，就会白白的造成selector进行空轮询的消耗，并且即使有读、写事件就绪了，还是得经历一系列调度然后再从主线程(Poller)切换到工作线程(线程池的线程)，增加了线程上下文的切换的消耗。可能听来没什么感觉，但这是服务器端程序，我们希望的是能管理大量的连接和请求的快速响应，由于特殊原因造成大量的连接占用了可以正常进行数据读写的连接通道所需的资源，这当然不是我们所期望的，所以为了在连接的管理和响应之间进行协调，Tomcat加入了一个组件NioSelectorPool，用来作channel读写超时的监控与连接的辅助管理，之前在Endpoint初始化时，调用了NioSelectorPool的open()，可以看看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        enabled = <span class="keyword">true</span>;</div><div class="line">        getSharedSelector();</div><div class="line">        <span class="keyword">if</span> (SHARED) &#123;</div><div class="line">            blockingSelector = <span class="keyword">new</span> NioBlockingSelector();</div><div class="line">            blockingSelector.open(getSharedSelector());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先会调用一个方法getSharedSelector()方法，这个方法会使用双重校验锁的方式实例化一个selector单例，接下来会判断如果是共享(SHARED)，就实例化一个NioBlockingSelector对象，这里先说明一下，这个SHARED表示的含义是NioSelectorPool是否共享同一个selector(默认为true)，如果不共享那么NioSelectorPool内部会维护一个selector池，selector不够用时则创建新的selector。接着后面的代码，blockingSelector会调用一个open()方法，它里面的逻辑就是把当前的selector赋值给它内部的selector，并且启动一个BlockPoller轮询器线程，这个BlockPoller与Poller做的事情类似。再来看到NioSocketWrapper，它内部也会获取到EndPoint中NioSelectorPool的实例，这里以读操作来分析，它的read()方法最终会调用到这么一个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fillReadBuffer</span><span class="params">(<span class="keyword">boolean</span> block, ByteBuffer to)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            <span class="keyword">int</span> nRead;</div><div class="line">            NioChannel channel = getSocket();</div><div class="line">            <span class="keyword">if</span> (block) &#123;</div><div class="line">                Selector selector = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 获取到NioSelectorPool中的selector</span></div><div class="line">                    selector = pool.get();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">                    <span class="comment">// Ignore</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel</div><div class="line">                            .getAttachment();</div><div class="line">                    <span class="keyword">if</span> (att == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Key must be cancelled."</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果是阻塞直接调用pool里面的read方法，并传入超时时间</span></div><div class="line">                    nRead = pool.read(to, channel, selector, att.getReadTimeout());</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (selector != <span class="keyword">null</span>) &#123;</div><div class="line">                        pool.put(selector);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不是阻塞则直接调用channel的read()方法</span></div><div class="line">                nRead = channel.read(to);</div><div class="line">                <span class="keyword">if</span> (nRead == -<span class="number">1</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> nRead;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>这里可以看到，首先会进行判断，如果是非阻塞则会直接调用channel.read()就完事了，但如果是阻塞会调用到pool里面的read()方法，接着跟进去这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer buf, NioChannel socket, Selector selector, <span class="keyword">long</span> readTimeout, <span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> ( SHARED &amp;&amp; block ) &#123;</div><div class="line">            <span class="comment">// 如果共享 且是阻塞 则直接调用BlockingSelector.read()方法</span></div><div class="line">            <span class="keyword">return</span> blockingSelector.read(buf,socket,readTimeout);</div><div class="line">        &#125;</div><div class="line">        SelectionKey key = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> keycount = <span class="number">1</span>;</div><div class="line">        <span class="keyword">long</span> time = System.currentTimeMillis(); <span class="comment">//start the timeout timer</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> ( (!timedout) ) &#123;</div><div class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> ( keycount &gt; <span class="number">0</span> ) &#123; </div><div class="line">                    <span class="comment">// 如果有事件 则直接从SocketChannel里面读</span></div><div class="line">                    cnt = socket.read(buf);</div><div class="line">                    <span class="keyword">if</span> (cnt == -<span class="number">1</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</div><div class="line">                            read = -<span class="number">1</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 已读取数据的字节数</span></div><div class="line">                    read += cnt;</div><div class="line">                    <span class="comment">// cnt &gt; 0表示读到数据了，再继续尝试读</span></div><div class="line">                    <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) <span class="keyword">continue</span>; </div><div class="line">                    <span class="comment">// 如果本次没读到数据，但之前已经读到了 说明数据读完了 直接跳出循环</span></div><div class="line">                    <span class="keyword">if</span> (cnt==<span class="number">0</span> &amp;&amp; (read&gt;<span class="number">0</span> || (!block) ) ) <span class="keyword">break</span>; </div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> ( selector != <span class="keyword">null</span> ) &#123;</div><div class="line">                    <span class="comment">// 重新注册当前channel的读事件到selector</span></div><div class="line">                    <span class="keyword">if</span> (key==<span class="keyword">null</span>) key = socket.getIOChannel().register(selector, SelectionKey.OP_READ);</div><div class="line">                    <span class="keyword">else</span> key.interestOps(SelectionKey.OP_READ);</div><div class="line">                    <span class="keyword">if</span> (readTimeout==<span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// 如果没设置超时时间，下一轮会直接退出该循环</span></div><div class="line">                        timedout = (read==<span class="number">0</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readTimeout&lt;<span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// 如果没设置读取超时时间 则直接select()进行阻塞等待事件就绪</span></div><div class="line">                        keycount = selector.select();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// 同样select() 但等待超时时间后立即返回</span></div><div class="line">                        keycount = selector.select(readTimeout);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 计算是否超时</span></div><div class="line">                <span class="keyword">if</span> (readTimeout &gt; <span class="number">0</span> &amp;&amp; (selector == <span class="keyword">null</span> || keycount == <span class="number">0</span>) ) timedout = (System.currentTimeMillis()-time)&gt;=readTimeout;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 超时了直接抛出异常</span></div><div class="line">            <span class="keyword">if</span> ( timedout ) <span class="keyword">throw</span> <span class="keyword">new</span> SocketTimeoutException();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">                key.cancel();</div><div class="line">                <span class="keyword">if</span> (selector != <span class="keyword">null</span>) selector.selectNow();<span class="comment">//removes the key from this selector</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> read;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，首先到NioSocketWrapper的read()到这里后，会判断是否是共享并且使用阻塞的方式(这里传入的直接是true，所以只要判断SHARED)，是的话直接调用blockingSelector.read()方法。我们可以先看看不满足情况下，后面的逻辑，会在一个while()循环，首先直接尝试读数据，如果读到了数据会继续尝试下一次读，如果没读到会重新把当前的channel注册读事件到当前的selector，然后会调用selector.select()进行阻塞，直到有读事件就绪，就会再去读数据，阻塞的时间如果达到超时时间就会立即返回，如果channel最后还是没有事件就绪的话，就会退出循环，抛出超时异常。可以看到这里selector的用法跟常规的不一样，逻辑走到我们肯定是不用共享selector或者使用非阻塞，但之前调用的时候就是当作阻塞来处理的，所以这里其实是使用了selector池，也就是说会对每一个SocketChannel分配一个selector来进行超时监控，有数据读直接就完事了，开始没读到数据的话也还是会将事件重新注册到当前的selector，最多等待设置的超时的时间，这样也不关主selector(Poller)什么事了。接看到进入到BlockingSelector的情况，直接看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer buf, NioChannel socket, <span class="keyword">long</span> readTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">         ......</div><div class="line">        NioSocketWrapper att = (NioSocketWrapper) key.attachment();</div><div class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> keycount = <span class="number">1</span>; <span class="comment">//assume we can read</span></div><div class="line">        <span class="keyword">long</span> time = System.currentTimeMillis(); <span class="comment">//start the timeout timer</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span>(!timedout) &#123;</div><div class="line">                <span class="keyword">if</span> (keycount &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 直接读数据</span></div><div class="line">                    read = socket.read(buf);</div><div class="line">                    <span class="keyword">if</span> (read != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> ( att.getReadLatch()==<span class="keyword">null</span> || att.getReadLatch().getCount()==<span class="number">0</span>) att.startReadLatch(<span class="number">1</span>);</div><div class="line">                     <span class="comment">// 添加读事件到BlockPoller的事件队列</span></div><div class="line">                    poller.add(att,SelectionKey.OP_READ, reference);</div><div class="line">                    <span class="keyword">if</span> (readTimeout &lt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// 没有设置超时则一直等待</span></div><div class="line">                        att.awaitReadLatch(Long.MAX_VALUE, TimeUnit.MILLISECONDS);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// 最多等待超时的时间</span></div><div class="line">                        att.awaitReadLatch(readTimeout, TimeUnit.MILLISECONDS);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</div><div class="line">                    <span class="comment">// Ignore</span></div><div class="line">                &#125;</div><div class="line">                ......</div><div class="line">                <span class="keyword">if</span> (readTimeout &gt;= <span class="number">0</span> &amp;&amp; (keycount == <span class="number">0</span>))</div><div class="line">                    timedout = (System.currentTimeMillis() - time) &gt;= readTimeout;</div><div class="line">            &#125; <span class="comment">//while</span></div><div class="line">            <span class="keyword">if</span> (timedout)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SocketTimeoutException();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> read;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到从逻辑上，与NioSelectorPool里面的read()做的事情是类似的，只是这里因为是使用的共享selector，所以使用了att.awaitxxxLatch()方法来计数，也就是NioSocketWrapper里面的这几个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">awaitLatch</span><span class="params">(CountDownLatch latch, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">            <span class="keyword">if</span> ( latch == <span class="keyword">null</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Latch cannot be null"</span>);</div><div class="line">            <span class="comment">// Note: While the return value is ignored if the latch does time</span></div><div class="line">            <span class="comment">//       out, logic further up the call stack will trigger a</span></div><div class="line">            <span class="comment">//       SocketTimeoutException</span></div><div class="line">            latch.await(timeout,unit);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitReadLatch</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; awaitLatch(readLatch,timeout,unit);&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitWriteLatch</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; awaitLatch(writeLatch,timeout,unit);&#125;</div></pre></td></tr></table></figure></p>
<p>也就是使用的CountDownLatch来作为超时的倒计时器，各个NioSocketWrapper相互之间不会受到影响，现在关键是要搞清楚这里阻塞了，在哪里进行收到通知解除阻塞。前面使用selector池时，因为每个SocketChannel是单独的selector监控和管理；这里使用共享的方式，关键依赖的就是BlockPoller了，前面说过它与Poller类似，同样的是从事件队列里面取出事件然后在selector里面进行注册，因为是管理多个SocketChannel，必然要查询有事件就绪的channel，然后分别处理，所以它的run方法里面有这么一段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;SelectionKey&gt; iterator = keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</div><div class="line"><span class="keyword">while</span> (run &amp;&amp; iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</div><div class="line">    SelectionKey sk = iterator.next();</div><div class="line">    NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">           iterator.remove();</div><div class="line">           sk.interestOps(sk.interestOps() &amp; (~sk.readyOps()));</div><div class="line">            <span class="keyword">if</span> ( sk.isReadable() ) &#123;</div><div class="line">                 countDown(attachment.getReadLatch());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (sk.isWritable()) &#123;</div><div class="line">                 countDown(attachment.getWriteLatch());</div><div class="line">            &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</div><div class="line">                            sk.cancel();</div><div class="line">                            countDown(attachment.getReadLatch());</div><div class="line">                            countDown(attachment.getWriteLatch());</div><div class="line">              &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>熟悉的代码，可以看到拿到读、写事件就绪的SocketChannel对应的SelectionKey后，会先取消事件，防止下次仍然被查询出来，然后就会根据事件类型进行判断，最后会调用countDown()方法来通知之前在NioBlockingSelector.read()里面阻塞的地方，接着循环开始下一轮，又可以读数据了。到这里，读写数据的流程就清楚了，这里还有需要注意的点是，NioSocketWrapper的read()方法是阻塞时才会使用NioSelectorPool进行处理，否则直接调用channel的read()方法；对于write()而言，是直接就丢到NioSelectorPool里面进行处理的，因为到需要响应数据时，已经经历了连接的建立、数据的读取与解析、业务的处理这些过程了，所以写数据对速度更加有要求，一般情况下都能正常写，但网络不通畅或者需要持续写数据的时候，如果重新再从Poller里面来进行调度，未免浪费时间，直接在辅助selector内部处理了，不需要切换线程，也能让数据响应的时间更快。最后再总结一下NioSelectorPool的工作方式和作用</p>
<ul>
<li>两种方式: 第一种使用共享的selector来处理多个SocketChannel，也就是NioBlockingSelector中启用单独的线程BlockPoller会进行通道是否有事件就绪的查询；第二种是非共享的方式，也就直接在NioSelectorPool里面维护了一个selector池，为每个channel分配一个selector进行超时监控，selector用完则重新丢回selector池。</li>
<li>作为辅助的selector，能提高主selector(Poller)处理并发连接的数量，对读写的超时进行监控，网络连接较慢时或者需要持续读写时能减少从主线程(Poller)到工作线程(线程池中的线程)的线程上下文切换和调度的开销。</li>
</ul>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这篇博客从源码入手，分析了Tomcat的初始化、启动和从建立连接到数据读写的过程，比较大的体会魔鬼藏在细节中，读这种源码时即使是断点调试一步步跟进，也会由于分支太多，很容易偏移主线，所以一定要先在宏观上有一个整体的把握，再带着问题去研究具体的模块才能有比较好的效果。</p>
<p>参考<br><a href="https://dbaplus.cn/news-134-1990-1.html" target="_blank" rel="external">https://dbaplus.cn/news-134-1990-1.html</a><br><a href="https://time.geekbang.org/column/intro/180" target="_blank" rel="external">https://time.geekbang.org/column/intro/180</a><br><a href="http://www.10tiao.com/html/308/201606/2650075890/1.html" target="_blank" rel="external">http://www.10tiao.com/html/308/201606/2650075890/1.html</a><br><a href="https://gearever.iteye.com/blog/1844203" target="_blank" rel="external">https://gearever.iteye.com/blog/1844203</a><br><a href="https://www.linuxidc.com/Linux/2015-02/113900p2.htm" target="_blank" rel="external">https://www.linuxidc.com/Linux/2015-02/113900p2.htm</a></p>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p>纯属好玩</p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">扫码打赏，你说多少就多少</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/alipay.png" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/weixin.png" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){
            
            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/08/12/Tomcat剖析之源码篇-二/">Tomcat剖析之源码篇(二)</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Legend 的个人博客">Legend</a></p>
        <p><span>发布时间:</span>2019年08月12日 - 14时29分</p>
        <p><span>最后更新:</span>2019年08月12日 - 14时34分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/08/12/Tomcat剖析之源码篇-二/" title="Tomcat剖析之源码篇(二)">http://blog.cspojie.cn/2019/08/12/Tomcat剖析之源码篇-二/</a>
            <span class="copy-path" data-clipboard-text="原文: http://blog.cspojie.cn/2019/08/12/Tomcat剖析之源码篇-二/　　作者: Legend" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2020/01/01/回首2019/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          回首2019
        
      </div>
    </a>
  
  
    <a href="/2019/07/14/Tomcat剖析之架构篇(一)/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Tomcat剖析之架构篇(-)</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从初始化开始"><span class="toc-number">2.</span> <span class="toc-text">从初始化开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期"><span class="toc-number">3.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat内部的线程池"><span class="toc-number">3.1.</span> <span class="toc-text">Tomcat内部的线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Connector的初始化"><span class="toc-number">3.2.</span> <span class="toc-text">Connector的初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正式启动"><span class="toc-number">4.</span> <span class="toc-text">正式启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#容器的启动"><span class="toc-number">4.1.</span> <span class="toc-text">容器的启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池与Mapper的启动"><span class="toc-number">4.2.</span> <span class="toc-text">线程池与Mapper的启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Connector的启动"><span class="toc-number">4.3.</span> <span class="toc-text">Connector的启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EndPoint"><span class="toc-number">4.4.</span> <span class="toc-text">EndPoint</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一次请求的过程"><span class="toc-number">5.</span> <span class="toc-text">一次请求的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Acceptor"><span class="toc-number">5.1.</span> <span class="toc-text">Acceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Poller"><span class="toc-number">5.2.</span> <span class="toc-text">Poller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Processor"><span class="toc-number">5.3.</span> <span class="toc-text">Processor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CoyoteAdapter"><span class="toc-number">5.4.</span> <span class="toc-text">CoyoteAdapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NioSelectorPool"><span class="toc-number">5.5.</span> <span class="toc-text">NioSelectorPool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结尾"><span class="toc-number">6.</span> <span class="toc-text">结尾</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <div id="gitments"></div>
<script src="/js/gitment.browser.js"></script>
<script src="https://www.wenjunjiang.win/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
      id: window.decodeURIComponent(window.location.pathname),
      owner: 'Xchuanshuo',
      repo: 'Xchuanshuo.github.io',
      oauth: {
        client_id: '84a8ba9556b4d1293665',
        client_secret: 'f6ce30da75414de93e37eb4a59102fbcb53ea568',
      },
    })
    gitment.render('gitments')
</script>
    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/01/01/回首2019/" title="上一篇: 回首2019">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2019/07/14/Tomcat剖析之架构篇(一)/" title="下一篇: Tomcat剖析之架构篇(-)">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/02/实现一个FC模拟器/">实现一个FC模拟器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/01/回首2019/">回首2019</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/Tomcat剖析之源码篇-二/">Tomcat剖析之源码篇(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/14/Tomcat剖析之架构篇(一)/">Tomcat剖析之架构篇(-)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/回首2018/">回首2018</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/JVM运行期优化/">JVM运行期优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/30/LRU与LFU缓存算法/">LRU与LFU缓存算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/平衡查找树之AVL树/">平衡查找树之AVL树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/16/Manacher算法求解最长回文子串/">Manacher算法求解最长回文子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/15/Java内存模型/">Java内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/02/Linux也可以这样美——Ubuntu18-04安装、配置、美化-踩坑记/">Linux也可以这样美——Ubuntu18.04安装、配置、美化-踩坑记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/JVM中的类加载机制/">JVM中的类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/08/坦白说解密/">坦白说解密</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/29/Java内存区域与内存溢出/">Java内存区域与内存溢出</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/13/仿MIUI实现带弹性的ScrollView/">仿MIUI实现带弹性的ScrollView</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/09/机器学习起步－k-最近邻算法/">机器学习起步－k-最近邻算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/14/Okhttp3的封装-搞定常用的请求/">Okhttp3的封装 搞定常用的请求</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/10/实现安卓无限轮播组件Banner/">实现安卓无限轮播组件Banner</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/31/浅谈Android中的MVP架构/">浅谈Android中的MVP架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/随机模拟算法求解圆周率/">随机模拟算法求解圆周率</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/21/Android第三方登录与服务器端验证过程/">Android第三方登录与服务器端验证过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/10/Django查错配置/">Django查错配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/04/Ubuntu16-04下Nginx-uwsgi部署Django项目/">Ubuntu16.04下Nginx+uwsgi部署Django项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/回首2017-展望未来/">回首2017 展望未来</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/Pycahrm远程调试Django项目/">Pycahrm远程调试Django项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/Python中的策略模式/">Python中的策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/图论-应用篇/">图论 应用篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/MySQL性能优化-一/">MySQL性能优化(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/20/图论-基础篇/">图论 基础篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/二叉堆与优先队列/">二叉堆与优先队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/06/Ubuntu下常用命令汇总/">Ubuntu下常用命令汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/02/分治思想之排序算法/">分治思想之排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/灵活-高效的符号表-二叉查找树/">灵活&&高效的符号表--二叉查找树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/Python3爬取百科词条-导入MySQL数据库/">Python3爬取百科词条+导入MySQL数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/常用的正则表达式整理/">常用的正则表达式整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/面向对象思想/">面向对象思想</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/25/玩转Python装饰器/">玩转Python装饰器</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>

 </div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 Legend
            </div>
            <div class="footer-right">
                
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >geek到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>